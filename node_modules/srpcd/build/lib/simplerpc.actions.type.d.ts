import { Node } from "ohm-js";
export interface SimpleRPCActions {
    Program?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    identifier?(t1: Node, t2: Node, ...t3: Node[]): any;
    identifierName?(t1: Node, t2: Node, ...t3: Node[]): any;
    identifierStart_escaped?(t1: Node, t2: Node, ...t3: Node[]): any;
    identifierStart?(t1: Node, ...t2: Node[]): any;
    identifierPart?(t1: Node, ...t2: Node[]): any;
    letter?(t1: Node, ...t2: Node[]): any;
    unicodeCategoryNl?(t1: Node, ...t2: Node[]): any;
    unicodeDigit?(t1: Node, ...t2: Node[]): any;
    unicodeCombiningMark?(t1: Node, ...t2: Node[]): any;
    unicodeConnectorPunctuation?(t1: Node, ...t2: Node[]): any;
    unicodeSpaceSeparator?(t1: Node, ...t2: Node[]): any;
    unicodeEscapeSequence?(t1: Node, t2: Node, t3: Node, t4: Node, t5: Node, ...t6: Node[]): any;
    packageName?(t1: Node, t2: Node, ...t3: Node[]): any;
    number_fract?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    number_whole?(t1: Node, ...t2: Node[]): any;
    number?(t1: Node, ...t2: Node[]): any;
    Datatype?(t1: Node, ...t2: Node[]): any;
    ArrayType?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    referenceName?(t1: Node, t2: Node, ...t3: Node[]): any;
    space?(t1: Node, ...t2: Node[]): any;
    comment_singleLine?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    comment_multiLine?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    comment?(t1: Node, ...t2: Node[]): any;
    openBracket?(t1: Node, ...t2: Node[]): any;
    closeBracket?(t1: Node, ...t2: Node[]): any;
    openParen?(t1: Node, ...t2: Node[]): any;
    closeParen?(t1: Node, ...t2: Node[]): any;
    openBrace?(t1: Node, ...t2: Node[]): any;
    closeBrace?(t1: Node, ...t2: Node[]): any;
    state?(t1: Node, t2: Node, ...t3: Node[]): any;
    data?(t1: Node, t2: Node, ...t3: Node[]): any;
    boolean?(t1: Node, t2: Node, ...t3: Node[]): any;
    string?(t1: Node, t2: Node, ...t3: Node[]): any;
    int?(t1: Node, t2: Node, ...t3: Node[]): any;
    float?(t1: Node, t2: Node, ...t3: Node[]): any;
    stream?(t1: Node, t2: Node, ...t3: Node[]): any;
    break?(t1: Node, t2: Node, ...t3: Node[]): any;
    do?(t1: Node, t2: Node, ...t3: Node[]): any;
    instanceof?(t1: Node, t2: Node, ...t3: Node[]): any;
    typeof?(t1: Node, t2: Node, ...t3: Node[]): any;
    case?(t1: Node, t2: Node, ...t3: Node[]): any;
    else?(t1: Node, t2: Node, ...t3: Node[]): any;
    new?(t1: Node, t2: Node, ...t3: Node[]): any;
    var?(t1: Node, t2: Node, ...t3: Node[]): any;
    catch?(t1: Node, t2: Node, ...t3: Node[]): any;
    finally?(t1: Node, t2: Node, ...t3: Node[]): any;
    return?(t1: Node, t2: Node, ...t3: Node[]): any;
    void?(t1: Node, t2: Node, ...t3: Node[]): any;
    continue?(t1: Node, t2: Node, ...t3: Node[]): any;
    for?(t1: Node, t2: Node, ...t3: Node[]): any;
    switch?(t1: Node, t2: Node, ...t3: Node[]): any;
    while?(t1: Node, t2: Node, ...t3: Node[]): any;
    debugger?(t1: Node, t2: Node, ...t3: Node[]): any;
    function?(t1: Node, t2: Node, ...t3: Node[]): any;
    this?(t1: Node, t2: Node, ...t3: Node[]): any;
    with?(t1: Node, t2: Node, ...t3: Node[]): any;
    default?(t1: Node, t2: Node, ...t3: Node[]): any;
    if?(t1: Node, t2: Node, ...t3: Node[]): any;
    throw?(t1: Node, t2: Node, ...t3: Node[]): any;
    delete?(t1: Node, t2: Node, ...t3: Node[]): any;
    in?(t1: Node, t2: Node, ...t3: Node[]): any;
    try?(t1: Node, t2: Node, ...t3: Node[]): any;
    get?(t1: Node, t2: Node, ...t3: Node[]): any;
    set?(t1: Node, t2: Node, ...t3: Node[]): any;
    class?(t1: Node, t2: Node, ...t3: Node[]): any;
    enum?(t1: Node, t2: Node, ...t3: Node[]): any;
    extends?(t1: Node, t2: Node, ...t3: Node[]): any;
    super?(t1: Node, t2: Node, ...t3: Node[]): any;
    const?(t1: Node, t2: Node, ...t3: Node[]): any;
    export?(t1: Node, t2: Node, ...t3: Node[]): any;
    import?(t1: Node, t2: Node, ...t3: Node[]): any;
    implements?(t1: Node, t2: Node, ...t3: Node[]): any;
    let?(t1: Node, t2: Node, ...t3: Node[]): any;
    private?(t1: Node, t2: Node, ...t3: Node[]): any;
    public?(t1: Node, t2: Node, ...t3: Node[]): any;
    interface?(t1: Node, t2: Node, ...t3: Node[]): any;
    package?(t1: Node, t2: Node, ...t3: Node[]): any;
    protected?(t1: Node, t2: Node, ...t3: Node[]): any;
    static?(t1: Node, t2: Node, ...t3: Node[]): any;
    yield?(t1: Node, t2: Node, ...t3: Node[]): any;
    version?(t1: Node, t2: Node, ...t3: Node[]): any;
    service?(t1: Node, t2: Node, ...t3: Node[]): any;
    interceptor?(t1: Node, t2: Node, ...t3: Node[]): any;
    sourceCharacter?(t1: Node, ...t2: Node[]): any;
    lineTerminator?(t1: Node, ...t2: Node[]): any;
    stringLiteral?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    singleStringCharacter_nonEscaped?(t1: Node, t2: Node, ...t3: Node[]): any;
    singleStringCharacter?(t1: Node, ...t2: Node[]): any;
    VersionExpression?(t1: Node, t2: Node, ...t3: Node[]): any;
    PackageExpression?(t1: Node, t2: Node, ...t3: Node[]): any;
    reservedWord?(t1: Node, ...t2: Node[]): any;
    nullLiteral?(t1: Node, t2: Node, ...t3: Node[]): any;
    booleanLiteral?(t1: Node, t2: Node, ...t3: Node[]): any;
    reservedIdentifiers?(t1: Node, ...t2: Node[]): any;
    builtindatatype?(t1: Node, ...t2: Node[]): any;
    keyword?(t1: Node, ...t2: Node[]): any;
    futureReservedWordLax?(t1: Node, ...t2: Node[]): any;
    futureReservedWordStrict?(t1: Node, ...t2: Node[]): any;
    futureReservedWord?(t1: Node, ...t2: Node[]): any;
    InterceptorDeclaration?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    InterceptorArgs?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    InterceptorCall?(t1: Node, t2: Node, t3: Node, t4: Node, ...t5: Node[]): any;
    InterceptorCallElements?(t1: Node, ...t2: Node[]): any;
    DataDeclaration?(t1: Node, t2: Node, t3: Node, t4: Node, t5: Node, ...t6: Node[]): any;
    DataBody?(t1: Node, ...t2: Node[]): any;
    DataProperty?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    ImportElements?(t1: Node, ...t2: Node[]): any;
    ImportDeclaration?(t1: Node, t2: Node, ...t3: Node[]): any;
    InterceptedServiceClassDeclaration?(t1: Node, t2: Node, ...t3: Node[]): any;
    InterceptedClassDeclaration?(t1: Node, t2: Node, ...t3: Node[]): any;
    InterceptedMethod?(t1: Node, t2: Node, ...t3: Node[]): any;
    ServiceClassDeclaration?(t1: Node, t2: Node, ...t3: Node[]): any;
    ClassDeclaration?(t1: Node, t2: Node, t3: Node, t4: Node, t5: Node, ...t6: Node[]): any;
    ClassBody?(t1: Node, t2: Node, ...t3: Node[]): any;
    ClassProperties?(t1: Node, ...t2: Node[]): any;
    ClassData?(t1: Node, t2: Node, ...t3: Node[]): any;
    ClassMethod?(t1: Node, t2: Node, t3: Node, t4: Node, ...t5: Node[]): any;
    ClassMethodArgs?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    FormalParameterList?(t1: Node, ...t2: Node[]): any;
    FormalParameter?(t1: Node, t2: Node, t3: Node, ...t4: Node[]): any;
    SourceElement?(t1: Node, ...t2: Node[]): any;
    Declaration?(t1: Node, ...t2: Node[]): any;
    alnum?(t1: Node, ...t2: Node[]): any;
    digit?(t1: Node, ...t2: Node[]): any;
    hexDigit?(t1: Node, ...t2: Node[]): any;
    ListOf?(t1: Node, ...t2: Node[]): any;
    NonemptyListOf?(t1: Node, t2: Node, ...t3: Node[]): any;
    EmptyListOf?(t1: Node, ...t2: Node[]): any;
    listOf?(t1: Node, ...t2: Node[]): any;
    nonemptyListOf?(t1: Node, t2: Node, ...t3: Node[]): any;
    emptyListOf?(t1: Node, ...t2: Node[]): any;
    any?(t1: Node, ...t2: Node[]): any;
    end?(t1: Node, ...t2: Node[]): any;
    caseInsensitive?(t1: Node, ...t2: Node[]): any;
    lower?(t1: Node, ...t2: Node[]): any;
    upper?(t1: Node, ...t2: Node[]): any;
    unicodeLtmo?(t1: Node, ...t2: Node[]): any;
    spaces?(t1: Node, ...t2: Node[]): any;
}
