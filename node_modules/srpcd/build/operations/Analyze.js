"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Analyze = void 0;
const symbolType_1 = require("../core/symbolType");
exports.Analyze = {
    Program(t1, t2, t3, t4) {
        this._symbol;
        t4.analyze();
    },
    DataDeclaration(t1, identifier, t3, dataBody, t5) {
        dataBody.analyze();
    },
    DataProperty(identifier, t2, datatype) {
        const _symbol = this._symbol;
        datatype.analyze()(_symbol, symbolType_1.PropertyTypes);
    },
    InterceptedMethod(t1, t2, ...t3) {
        // return t2._symbol
    },
    InterceptedServiceClassDeclaration(t1, t2, ...t3) {
        // return t2.analyze();
    },
    InterceptedClassDeclaration(t1, t2, ...t3) {
        // return t2.analyze();
    },
    InterceptorCall(t1, t2, t3, t4, ...t5) {
        // return t2.analyze();
    },
    InterceptorDeclaration(t1, t2, t3, ...t4) { },
    InterceptorArgs(t1, t2, t3, ...t4) { },
    ServiceClassDeclaration(t1, t2, ...t3) {
        return t2.analyze();
    },
    ClassDeclaration(t1, identifier, t3, classBody, t5) {
        classBody.analyze();
    },
    ClassBody(state, methods, ...t3) {
        state.analyze();
        methods.analyze();
    },
    ClassData(t1, datatype, ...t3) {
        const _symbol = this._symbol;
        datatype.analyze()(_symbol, [symbolType_1.SymbolType.DATA]);
    },
    ClassMethod(identifier, classMethodArgs, t3, datatype) {
        const _symbol = this._symbol;
        datatype.analyze()(_symbol, symbolType_1.ReturnTypes);
    },
    Datatype(t1) {
        return function (_symbol, types) {
            t1.analyze && t1.analyze()(_symbol, types);
        };
    },
    referenceName(t1, t2, ...t3) {
        return (_symbol, types) => {
            checkDatatype(_symbol.global, this, types);
        };
    },
    builtindatatype(t1) {
        return function (_symbol, types) {
            checkDatatype(_symbol.global, t1, types);
        };
    },
    ArrayType(t1, t2, t3) {
        return function (_symbol, types) {
            checkDatatype(_symbol.global, t1, types);
        };
    },
};
function checkDatatype(scope, datatype, types) {
    const identifier = datatype.sourceString;
    const type = scope.getSymbolType(identifier);
    if (!type || !types.includes(type))
        throw new Error('Invalid type ' + identifier + '\n' +
            datatype.source.getLineAndColumnMessage());
}
