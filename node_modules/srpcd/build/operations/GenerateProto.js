"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toProtoDataType = exports.GenerateProto = void 0;
const tmp = require("tmp");
const path = require("path");
const util_1 = require("util");
const shelljs = require("shelljs");
const fs = require("fs");
const types_1 = require("../attributes/helpers/types");
exports.GenerateProto = {
    Program(t1, t2, t3) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = yield this.descriptor;
            const classes = Array.from(file.declarations.values())
                .filter(m => m.type === types_1.SymbolType.CLASS);
            let map = {}, proto = '';
            const declarationNode = yield Promise.all(yield t3.generateProto());
            declarationNode.forEach((code) => {
                proto += code;
            });
            classes.forEach((ref) => {
                var _a, _b, _c, _d;
                const { interceptors, declarations } = ref;
                const class_name = ref.toReference();
                map[class_name] = { methods: {} };
                const [data] = Array.from(declarations.values()).filter(p => p.type === types_1.SymbolType.VARIABLE);
                if (data)
                    map[class_name]['proto_class_data_type'] = toProtoIdentifier((_a = data.datatype.reference) === null || _a === void 0 ? void 0 : _a.toReference());
                if (interceptors)
                    map[class_name]['interceptors'] = Array.from(interceptors.values()).map(interceptor => ({
                        identifier: interceptor.toReference()
                    }));
                for (const { identifier, interceptors, return_type: _return, parameters: parameters } of Array.from(declarations.values()).filter(p => p.type === types_1.SymbolType.FUNCTION)) {
                    const proto_request_type = toProtoIdentifier(class_name + identifier + 'Request');
                    const proto_return_type = toProtoIdentifier(class_name + identifier + 'Response');
                    let _interceptors;
                    if (interceptors)
                        _interceptors = Array.from(interceptors.values()).map(interceptor => ({
                            identifier: interceptor.toReference()
                        }));
                    map[class_name]['methods'][identifier] = {
                        interceptors: _interceptors,
                        request_type: {
                            proto: proto_request_type,
                            args: Array.from(parameters.entries())
                                .sort((a, b) => a[0] - b[0])
                                .map((arg, index) => arg[1])
                                .map((arg, index) => ({
                                index,
                                identifier: arg.identifier,
                            })),
                        },
                        return_type: {
                            proto: proto_return_type,
                            ctor: (_b = _return.reference) === null || _b === void 0 ? void 0 : _b.toReference(),
                            reference: !!((_c = _return.reference) === null || _c === void 0 ? void 0 : _c.identifier),
                            datatype: ((_d = _return.reference) === null || _d === void 0 ? void 0 : _d.type) || _return.type
                        },
                    };
                }
            });
            const pbjs = require("protobufjs/cli/pbjs");
            const combine = () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (file.is_root_file) {
                    let p = 'syntax = "proto2";\n';
                    const { proto: _proto, map: _map } = yield ((_a = file.program) === null || _a === void 0 ? void 0 : _a.semantics().generateProto());
                    p += _proto;
                    Object.assign(map, JSON.parse(_map));
                    for (let dependence of ((_b = file.program) === null || _b === void 0 ? void 0 : _b.dependencies) || []) {
                        const { proto: _proto, map: _map } = yield dependence.semantics().generateProto();
                        p += yield _proto;
                        Object.assign(map, JSON.parse(_map));
                    }
                    proto = p + proto;
                    return { proto, map };
                }
                return { proto, map };
            });
            return combine()
                .then(({ proto, map }) => {
                return {
                    proto,
                    proto_json: () => __awaiter(this, void 0, void 0, function* () {
                        let { name: os_temp_dir } = tmp.dirSync({ mode: 0o750, prefix: 'myTmpDir_' });
                        fs.writeFileSync(path.resolve(os_temp_dir, `def.proto`), proto, { encoding: "utf8" });
                        const json = yield util_1.promisify(pbjs.main)(["--target", "json", "--keep-case", path.resolve(os_temp_dir, `def.proto`)]);
                        shelljs.rm('-rf', os_temp_dir);
                        return json;
                    }),
                    map: JSON.stringify(map, null, '  ')
                };
            });
            // .catch(console.log).then(() => ({proto, proto_static: '', proto_json: ''}))
        });
    },
    DataDeclaration(t1, t2, t3, t4, t5) {
        return __awaiter(this, void 0, void 0, function* () {
            const ref = yield this.descriptor;
            const { identifier, declarations: _properties } = ref;
            const properties = Array.from(_properties)
                .map((arg) => arg[1])
                .filter(({ datatype }) => toProtoDataType(datatype))
                .map(({ identifier, datatype }, index) => `${toProtoDataType(datatype)} ${identifier} = ${index + 1};`);
            return '\n' + constructProtoMessage(toProtoIdentifier(ref.toReference()), properties);
        });
    },
    InterceptedMethod(t1, t2, ...t3) {
        return t2.generateProto();
    },
    InterceptedServiceClassDeclaration(t1, t2, ...t3) {
        return t2.generateProto();
    },
    InterceptedClassDeclaration(t1, t2, ...t3) {
        return t2.generateProto();
    },
    InterceptorCall(t1, t2, t3, t4, ...t5) {
        return '';
    },
    InterceptorDeclaration(t1, t2, t3, ...t4) {
        return '';
    },
    InterceptorArgs(t1, t2, t3, ...t4) {
        return '';
    },
    ServiceClassDeclaration(t1, t2, ...t3) {
        return __awaiter(this, void 0, void 0, function* () {
            return t2.generateProto();
        });
    },
    ClassDeclaration(t1, t2, t3, t4, t5) {
        return __awaiter(this, void 0, void 0, function* () {
            const ref = yield this.descriptor;
            const { declarations } = ref;
            const class_name = toProtoIdentifier(ref.toReference());
            const [data] = Array.from(declarations.values())
                .filter(m => m.type === types_1.SymbolType.VARIABLE);
            const methods = Array.from(declarations.values())
                .filter(m => m.type === types_1.SymbolType.FUNCTION);
            let declaration = '';
            for (const { identifier, return_type: _return, parameters: _arguments } of methods) {
                const props = Array.from(_arguments)
                    .sort((a, b) => a[0] - b[0])
                    .map((arg) => arg[1])
                    .map(({ identifier, datatype }, index) => `${toProtoDataType(datatype)} ${identifier} = ${index + 1};`);
                const proto_request_type = class_name + identifier + 'Request';
                const proto_return_type = class_name + identifier + 'Response';
                declaration += '\n';
                declaration += constructProtoMessage(proto_request_type, props);
                declaration += '\n';
                declaration += constructProtoMessage(proto_return_type, [
                    { identifier: 'data', datatype: data === null || data === void 0 ? void 0 : data.datatype },
                    { identifier: 'response', datatype: _return },
                ].filter(k => !!k.datatype && toProtoDataType(k.datatype))
                    .map(({ identifier, datatype }, index) => `${toProtoDataType(datatype)} ${identifier} = ${index + 1};`));
            }
            declaration += '\n';
            return declaration;
        });
    },
};
function constructProtoMessage(name, body) {
    body = !Array.isArray(body) ? [body] : body;
    body = body.filter(b => b.trim().length);
    return `message ${name} {${body.length ? '\n\t' : ''}${body.join('\n\t')}${body.length ? '\n' : ''}}`;
}
const datatype_dictionary = {
    int: 'int64',
    boolean: 'bool'
};
function toProtoIdentifier(str) {
    return str.split('.')
        .join(' ')
        .replace(/(?:^\w|[A-Z]|\b\w)/g, function (word, index) {
        return word.toUpperCase();
    }).replace(/\s+/g, '');
}
function toProtoDataType({ repeated, reference, type }) {
    let _type;
    if (reference) {
        if (reference.type === types_1.SymbolType.DATA)
            _type = toProtoIdentifier(reference === null || reference === void 0 ? void 0 : reference.toReference());
        else if (reference.type === types_1.SymbolType.CLASS) {
            const [data] = Array.from(reference.declarations.values()).filter(p => p.type === types_1.SymbolType.VARIABLE);
            _type = toProtoIdentifier(data === null || data === void 0 ? void 0 : data.datatype.toReference());
        }
    }
    else
        _type = datatype_dictionary[type] || type;
    return _type ? `${repeated ? 'repeated' : 'optional'} ${_type}` : false;
}
exports.toProtoDataType = toProtoDataType;
