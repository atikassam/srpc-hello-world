"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toTsDataType = exports.GenerateWebClient = void 0;
const fs = require("fs");
const path = require("path");
const types_1 = require("../attributes/helpers/types");
exports.GenerateWebClient = {
    Program(t1, t2, t3) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = yield this.descriptor;
            const classes = Array.from(file.declarations.values())
                .filter(m => m.type === types_1.SymbolType.CLASS);
            let logic = '';
            let include = fs.readFileSync(path.resolve(__dirname, '../helper_codes/web.client.include.ts'), "utf8");
            logic += `\nexport namespace ${file.package.identifier} {\n`;
            (yield Promise.all(t3.generateWebClient())).forEach((code) => {
                logic += code.split('\n').join('\n\t');
            });
            logic += '\n}';
            const combine = () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                let p = '';
                if (file.is_root_file) {
                    p += include;
                    p += '\n' +
                        'export class Services extends RpcServices {\n' +
                        '  constructor(protected ___client: RpcClient) {\n' +
                        '    super(___client);\n' +
                        '    for (let service in this) {\n' +
                        '      if (typeof this[service] === "object" && service !== \'___client\')\n' +
                        '        (this[service] as any).__rpc_client = this.___client;\n' +
                        '    }\n' +
                        '  }\n';
                    classes.forEach((ref) => {
                        p += `\n\t'${ref.toReference()}':${ref.toReference()} = new ${ref.toReference()}();`;
                    });
                    p += '\n\t___class_ctors = {';
                    classes.forEach((ref) => p += `\n\t\t'${ref.toReference()}': ${ref.toReference()},`);
                    p += '\n\t}';
                    p += '\n}';
                    p += '\n';
                    const { logic: code } = yield ((_a = file.program) === null || _a === void 0 ? void 0 : _a.semantics().generateWebClient());
                    p += code;
                    for (let dependence of ((_b = file.program) === null || _b === void 0 ? void 0 : _b.dependencies) || []) {
                        const { logic: code } = yield dependence.semantics().generateWebClient();
                        p += yield code;
                    }
                    return p + logic;
                }
                return p + logic;
            });
            return { client: yield combine(), include, logic };
        });
    },
    DataDeclaration(t1, identifier, t3, dataBody, t5) {
        return __awaiter(this, void 0, void 0, function* () {
            const meta = yield this.descriptor;
            const properties = Array.from(meta.declarations)
                .map((arg) => arg[1])
                .map(({ identifier, datatype }) => `${identifier}: ${toTsDataType(datatype)}`);
            return `\nexport interface ${meta.identifier} {\n\t${properties.join('\n\t')} \n}`;
        });
    },
    InterceptedMethod(t1, t2, ...t3) {
        return t2.generateWebClient();
    },
    InterceptedServiceClassDeclaration(t1, t2, ...t3) {
        return t2.generateWebClient();
    },
    InterceptedClassDeclaration(t1, t2, ...t3) {
        return t2.generateWebClient();
    },
    InterceptorCall(t1, t2, t3, t4, ...t5) {
        return '';
    },
    InterceptorDeclaration(t1, t2, t3, ...t4) {
        return '';
    },
    InterceptorArgs(t1, t2, t3, ...t4) {
        return '';
    },
    ServiceClassDeclaration(t1, t2, ...t3) {
        return __awaiter(this, void 0, void 0, function* () {
            const ref = yield this.descriptor;
            const { identifier } = ref;
            const code = '\n' +
                `export class ${identifier}Client extends RpcClient<${identifier}, Services> {\n` +
                '  constructor(protected url: string, protected headers: any) {\n' +
                '    super(url, headers, Services)\n' +
                '  }\n' +
                `  async init(): Promise<${ref.toReference()}>{\n` +
                '    await super.init();\n' +
                `    return this.services._createInstance('${ref.toReference()}', undefined)` +
                '  }\n' +
                '}\n';
            return code + (yield t2.generateWebClient());
        });
    },
    ClassDeclaration(t1, n2, t3, n4, t5) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const ref = yield this.descriptor;
            const { identifier, declarations } = ref;
            const [data] = Array.from(declarations.values())
                .filter(m => m.type === types_1.SymbolType.VARIABLE);
            const methods = Array.from(declarations.values())
                .filter(m => m.type === types_1.SymbolType.FUNCTION);
            let declaration = '\n' +
                `export class ${identifier} {\n` +
                '  private __rpc_client!: RpcClient;\n' +
                '  private async callMethod(name: string, data: any): Promise<any> {\n' +
                `    return this.__rpc_client.callMethod(this, '${ref.toReference()}', name, data)\n` +
                '  }\n';
            if (data) {
                declaration += '' +
                    `  private ${data.identifier}!: ${(_a = data.datatype.reference) === null || _a === void 0 ? void 0 : _a.toReference()};\n` +
                    `  getData(): ${(_b = data.datatype.reference) === null || _b === void 0 ? void 0 : _b.toReference()} { return this.${data.identifier} || {} }\n` +
                    `  __updateData(data: Partial<${(_c = data.datatype.reference) === null || _c === void 0 ? void 0 : _c.toReference()}>){ this.${data.identifier} = Object.assign(this.${data.identifier} || {}, data || {}) }\n` +
                    '';
            }
            for (const { identifier, return_type: _return, parameters: _arguments } of methods) {
                const args = Array.from(_arguments)
                    .sort((a, b) => a[0] - b[0])
                    .map((arg) => arg[1])
                    .map(({ identifier, datatype }) => `${identifier}: ${toTsDataType(datatype)}`);
                declaration += '' +
                    `  public ${identifier}(${args.join(', ')}): Promise<${toTsDataType(_return)}> {\n` +
                    `    return this.callMethod('${identifier}', arguments);\n` +
                    '  }\n';
            }
            declaration += '}';
            return declaration;
        });
    },
};
const datatype_dictionary = {
    int: 'number'
};
function toTsDataType({ reference, repeated, type }) {
    return `${type === types_1.SymbolType.REFERENCE ? reference === null || reference === void 0 ? void 0 : reference.toReference()
        : datatype_dictionary[type] || type}${repeated ? '[]' : ''}`;
}
exports.toTsDataType = toTsDataType;
