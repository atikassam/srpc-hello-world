"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenerateNodeServer = void 0;
const fs = require("fs");
const path = require("path");
const GenerateWebClient_1 = require("./GenerateWebClient");
const PackageDescriptor_1 = require("../attributes/helpers/PackageDescriptor");
const types_1 = require("../attributes/helpers/types");
exports.GenerateNodeServer = {
    Program(t1, t2, t3) {
        return __awaiter(this, void 0, void 0, function* () {
            const file = yield this.descriptor;
            const classes = Array.from(file.declarations.values())
                .filter(m => [types_1.SymbolType.CLASS, types_1.SymbolType.INTERCEPTOR].indexOf(m.type) > -1);
            let include = fs.readFileSync(path.resolve(__dirname, '../helper_codes/nodejs.server.include.ts'), "utf8");
            let program_code = '';
            program_code += `\nexport namespace ${file.package.identifier} {\n`;
            (yield Promise.all(t3.generateNodeServer())).forEach((code) => {
                program_code += code.split('\n').join('\n\t');
            });
            program_code += '\n}';
            const combine = () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                let p = '';
                if (file.is_root_file) {
                    p += include;
                    p += '\ninterface SrpcClasses {';
                    PackageDescriptor_1.PackageDescriptor.filter([types_1.SymbolType.CLASS, types_1.SymbolType.INTERCEPTOR]).forEach((_class) => {
                        p += `\n\t'${_class.toReference()}': typeof ${_class.toReference()};`;
                    });
                    p += '\n}\n';
                    const { code } = yield ((_a = file.program) === null || _a === void 0 ? void 0 : _a.semantics().generateNodeServer());
                    p += code;
                    for (let dependence of ((_b = file.program) === null || _b === void 0 ? void 0 : _b.dependencies) || []) {
                        const { code } = yield dependence.semantics().generateNodeServer();
                        p += yield code;
                    }
                    p += program_code;
                    return p;
                }
                return p + program_code;
            });
            return { server: yield combine(), include, code: program_code };
        });
    },
    DataDeclaration(t1, identifier, t3, dataBody, t5) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.generateWebClient();
        });
    },
    InterceptedMethod(t1, t2, ...t3) {
        return t2.generateNodeServer();
    },
    InterceptedServiceClassDeclaration(t1, t2, ...t3) {
        return t2.generateNodeServer();
    },
    InterceptedClassDeclaration(t1, t2, ...t3) {
        return t2.generateNodeServer();
    },
    InterceptorCall(t1, t2, t3, t4, ...t5) {
        return '';
    },
    InterceptorDeclaration(t1, t2, t3, ...t4) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, parameters: _arguments } = yield this.descriptor;
            const args = Array.from(_arguments)
                .sort((a, b) => a[0] - b[0])
                .map((arg) => arg[1])
                .map(({ identifier, datatype }) => `${identifier}: ${GenerateWebClient_1.toTsDataType(datatype)}`);
            const server = `\nexport abstract class ${identifier} {\n` +
                `  constructor(protected ctx: RpcProcessCtx){}` +
                `  abstract intercept(${args.join(', ')}): Promise<any>\n` +
                '}\n';
            return server;
        });
    },
    InterceptorArgs(t1, t2, t3, ...t4) {
    },
    ServiceClassDeclaration(t1, t2, ...t3) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier } = yield this.descriptor;
            const code = yield t2.generateNodeServer();
            const server = `\nexport class ${identifier}Srpc extends SrpcServer<SrpcClasses> {\n` +
                '  constructor(classes: SrpcClasses) {\n' +
                '    super(classes)\n' +
                '  }\n' +
                '}\n';
            return code + server;
        });
    },
    ClassDeclaration(t1, t2, t3, t4, t5) {
        return __awaiter(this, void 0, void 0, function* () {
            const { identifier, declarations } = yield this.descriptor;
            const methods = Array.from(declarations.values())
                .filter(m => m.type === types_1.SymbolType.FUNCTION);
            const [data] = Array.from(declarations.values())
                .filter(m => m.type === types_1.SymbolType.VARIABLE);
            let declaration = `\nexport abstract class ${identifier} {`;
            declaration += `\n\tprotected getCtx(): any {}`;
            if (data && data.datatype.type === types_1.SymbolType.REFERENCE) {
                const { datatype, identifier } = data;
                declaration += `\n\tprivate ${identifier}!: ${datatype.toReference()};`;
                declaration += `\n\tconstructor(data: ${datatype.toReference()}) { this.${identifier} = data; }` +
                    `\n\tgetData(){ return this.${identifier} }` +
                    `\n\tupdateData(data: Partial<${datatype.toReference()}>){ Object.assign(this.${identifier}, data) }` +
                    '';
            }
            for (const { identifier, return_type: _return, parameters: _arguments } of methods) {
                const args = Array.from(_arguments)
                    .sort((a, b) => a[0] - b[0])
                    .map((arg) => arg[1])
                    .map(({ identifier, datatype }) => `${identifier}: ${GenerateWebClient_1.toTsDataType(datatype)}`);
                declaration += `\n\tpublic abstract ${identifier}(${args.join(', ')}): Promise<${GenerateWebClient_1.toTsDataType(_return)}>`;
            }
            declaration += '\n}';
            return declaration;
        });
    },
};
