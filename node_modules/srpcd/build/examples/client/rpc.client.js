"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.auth = exports.Services = void 0;
const protobufjs = require("protobufjs/light");
const axios_1 = require("axios");
const FormData = require("form-data");
const buffer_1 = require("buffer");
const isBrowser = new Function("try {return this===window;}catch(e){ return false;}");
class RpcServices {
    constructor(___client) {
        this.___client = ___client;
        this.___class_ctors = {};
    }
    _createInstance(class_name, state) {
        return __awaiter(this, void 0, void 0, function* () {
            const _services = this;
            const ClassName = _services.___class_ctors[class_name];
            const instance = new ClassName(state);
            instance.__rpc_client = this.___client;
            instance.__updateData && instance.__updateData(state);
            return instance;
        });
    }
}
class RpcClient {
    constructor(url, headers, Services) {
        this.url = url;
        this.headers = headers;
        this.Services = Services;
    }
    get map() {
        if (!this._map)
            throw Error('Please initiate the app first');
        return this._map;
    }
    ;
    get root() {
        if (!this._root)
            throw Error('Please initiate the app first');
        return this._root;
    }
    ;
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this._map = yield require('./def.map.json');
            this._root = yield protobufjs.Root.fromJSON(require('./def.proto.json'));
            if (!this.services)
                this.services = new this.Services(this);
            return undefined;
        });
    }
    callMethod(instance, class_name, method_name, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoded = yield this._encodeRequest(instance, class_name, method_name, args);
            const response = yield this._callMethod(instance, class_name, method_name, encoded.data, encoded.args);
            return this._decodeResponse(instance, class_name, method_name, response);
        });
    }
    _decodeResponse(instance, class_name, method_name, _response) {
        return __awaiter(this, void 0, void 0, function* () {
            const ReturnType = yield this._getReturnType(class_name, method_name);
            const { isReturnTypeClass, return_type } = yield this._getMethodMetadata(class_name, method_name);
            const message = ReturnType.decode(_response);
            const { data, response } = ReturnType.toObject(message, {
                enums: String,
                longs: Number,
                bytes: String,
                defaults: true,
                arrays: true,
                objects: true,
                oneofs: true // includes virtual oneof fields set to the present field's name
            });
            instance.__updateData && instance.__updateData(data);
            if (isReturnTypeClass()) {
                return Array.isArray(response)
                    ? Promise.all(response.map((state) => this.services._createInstance(return_type.ctor, state)))
                    : yield this.services._createInstance(return_type.ctor, response);
            }
            return response;
        });
    }
    _callMethod(instance, class_name, method_name, data, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const form = new FormData(), headers = {};
            // For browser
            if (isBrowser()) {
                form.append('args', new Blob([args], { type: 'arraybuffer' }), 'args');
                data && form.append('data', new Blob([data], { type: 'arraybuffer' }), 'data');
            }
            else {
                form.append('args', args, { filename: 'args' });
                data && form.append('data', data, { filename: 'data' });
                Object.assign(headers, { 'content-type': `multipart/form-data; boundary=${form.getBoundary()}` });
            }
            form.append('method', method_name);
            form.append('class', class_name);
            try {
                const request = yield axios_1.default.post(this.url, form, {
                    responseType: "arraybuffer",
                    headers: Object.assign(headers, (typeof this.headers === "function"
                        ? yield this.headers()
                        : typeof this.headers === "object" && this.headers !== null
                            ? this.headers
                            : {}))
                });
                return buffer_1.Buffer.from(request.data, "binary");
            }
            catch (e) {
                throw e.response && e.response.data && e.response.data || e;
            }
        });
    }
    _encodeRequest(instance, class_name, method_name, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const RequestType = yield this._getRequestType(class_name, method_name);
            const ClassDataType = yield this._getDataType(class_name);
            // Encode a message to an Uint8Array (browser) or Buffer (node)
            const method_args = {};
            const method_arguments = yield this._getArgumentTypes(class_name, method_name);
            (method_arguments || []).forEach(({ index, identifier }) => {
                method_args[identifier] = args[index];
            });
            const encoded = {
                args: yield this._encodeWithType(RequestType, method_args),
                data: undefined
            };
            if (ClassDataType) {
                encoded['data'] = yield this._encodeWithType(ClassDataType, instance.getData());
            }
            console.log('Request for %s %s [%o] is [%o]', class_name, method_name, args, instance.getData());
            return encoded;
        });
    }
    _encodeWithType(type, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data)
                return;
            // 1. Verify data
            const errMsg = type.verify(data);
            if (errMsg)
                throw Error(errMsg);
            // 2. encode protobuf
            // Create a new message// or use .fromObject if conversion is necessary
            const message = type.create(data);
            // Encode a message to an Uint8Array (browser) or Buffer (node)
            return type.encode(message).finish();
        });
    }
    _getArgumentTypes(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { request_type } = yield this._getMethodMetadata(class_name, method_name);
            return request_type.args;
        });
    }
    _getRequestType(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { request_type } = yield this._getMethodMetadata(class_name, method_name);
            const type = this.root.lookupType(request_type.proto);
            if (!type)
                throw Error('Method not found');
            return type;
        });
    }
    _getReturnType(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { return_type } = yield this._getMethodMetadata(class_name, method_name);
            const type = this.root.lookupType(return_type.proto);
            if (!type)
                throw Error('Return type not found');
            return type;
        });
    }
    _getMethodMetadata(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = this.map[class_name]['methods'][method_name];
            const return_type = metadata['return_type'];
            const request_type = metadata['request_type'];
            return {
                metadata,
                request_type,
                return_type,
                return_proto_type: return_type.proto,
                return_constructor_type: return_type.ctor,
                isReturnTypeClass: () => {
                    return return_type.datatype === 'class';
                }
            };
        });
    }
    _getDataType(class_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const DataType = this.map[class_name]['proto_class_data_type'];
            if (!DataType)
                return;
            return this.root.lookupType(DataType);
        });
    }
}
class Services extends RpcServices {
    constructor(___client) {
        super(___client);
        this.___client = ___client;
        this['auth.File'] = new auth.File();
        this['auth.DriveService'] = new auth.DriveService();
        this.___class_ctors = {
            'auth.File': auth.File,
            'auth.DriveService': auth.DriveService,
        };
        for (let service in this) {
            if (typeof this[service] === "object" && service !== '___client')
                this[service].__rpc_client = this.___client;
        }
    }
}
exports.Services = Services;
var auth;
(function (auth) {
    class File {
        callMethod(name, data) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.__rpc_client.callMethod(this, 'auth.File', name, data);
            });
        }
        getData() { return this.$___class_state || {}; }
        __updateData(data) { this.$___class_state = Object.assign(this.$___class_state || {}, data || {}); }
        rename(name) {
            return this.callMethod('rename', arguments);
        }
        remove() {
            return this.callMethod('remove', arguments);
        }
        move(source, dest) {
            return this.callMethod('move', arguments);
        }
        files() {
            return this.callMethod('files', arguments);
        }
    }
    auth.File = File;
    class DriveServiceClient extends RpcClient {
        constructor(url, headers) {
            super(url, headers, Services);
            this.url = url;
            this.headers = headers;
        }
        init() {
            const _super = Object.create(null, {
                init: { get: () => super.init }
            });
            return __awaiter(this, void 0, void 0, function* () {
                yield _super.init.call(this);
                return this.services._createInstance('auth.DriveService', undefined);
            });
        }
    }
    auth.DriveServiceClient = DriveServiceClient;
    class DriveService {
        callMethod(name, data) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.__rpc_client.callMethod(this, 'auth.DriveService', name, data);
            });
        }
        getData() { return this.$___class_state || {}; }
        __updateData(data) { this.$___class_state = Object.assign(this.$___class_state || {}, data || {}); }
        rootFolder() {
            return this.callMethod('rootFolder', arguments);
        }
    }
    auth.DriveService = DriveService;
})(auth = exports.auth || (exports.auth = {}));
