"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.drive = void 0;
const protobufjs = require("protobufjs");
const http = require("http");
const Busboy = require("busboy");
const last = a => a[a.length - 1];
const reduce = a => a.slice(0, -1);
class RpcProcessor {
    constructor() {
        this.def_map = require('./def.map.json');
        this.root = protobufjs.Root.fromJSON(require('./def.proto.json'));
    }
    createCtx(_class, _method, _state, _args, _opts) {
        return {
            headers: _opts.headers,
            rpc_processor: this,
            protocol: 'http',
            raw: {
                class: _class,
                method: _method,
                state: _state,
                args: _args
            },
            protobuf: this.root,
            def_map: this.def_map,
        };
    }
    use(method) {
        this.process = ((stack) => (...args) => stack(...reduce(args), () => {
            const next = last(args);
            method.apply(this, [...reduce(args), next.bind.apply(next, [null, ...reduce(args)])]);
        }))(this.process);
    }
    process(...args) {
        last(args).apply(this, reduce(args));
    }
}
function init() { }
function decodeRequest() { }
function validateRequest() { }
function encodeRequest() { }
function validateResponse() { }
function callMethod() { }
const rpc_processor = new RpcProcessor();
rpc_processor.use(init);
rpc_processor.use(decodeRequest);
rpc_processor.use(validateRequest);
rpc_processor.use(callMethod);
rpc_processor.use(validateResponse);
rpc_processor.use(encodeRequest);
class SrpcServer {
    constructor(implementations) {
        this.implementations = implementations;
        this.useExpressHandler = (req, res) => {
            return this.requestHandler(req, res);
        };
        this.useKoaHandler = (ctx) => {
            return this.requestHandler(ctx.req, ctx.res);
        };
        this.init();
    }
    get map() {
        if (!this._map)
            throw Error('Please initiate the app first');
        return this._map;
    }
    ;
    get root() {
        if (!this._root)
            throw Error('Please initiate the app first');
        return this._root;
    }
    ;
    setErrorHandler(fnc) {
        this.errorHandler = fnc;
        return this;
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this._map = yield require('./def.map.json');
            this._root = yield protobufjs.Root.fromJSON(require('./def.proto.json'));
            return this;
        });
    }
    createServer(options) {
        return http.createServer((req, res) => {
            var _a, _b;
            if (options === null || options === void 0 ? void 0 : options.enable_cors)
                this.enableCors(req, res);
            if (((_a = req.method) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'OPTIONS'.toLowerCase())
                return res.writeHead(200).end();
            if (((_b = req.method) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== 'POST'.toLowerCase())
                return res.writeHead(405).end();
            this.requestHandler(req, res);
        });
    }
    requestHandler(req, res) {
        const meta = {}, busboy = new Busboy({ headers: req.headers });
        busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {
            const buf = [];
            file.on('data', (data) => buf.push(data));
            file.on('end', () => meta[fieldname] = Buffer.concat(buf));
        });
        busboy.on('field', function (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) {
            meta[fieldname] = val;
        });
        busboy.on('finish', () => __awaiter(this, void 0, void 0, function* () {
            const ctx = rpc_processor.createCtx(meta['class'], meta['method'], meta['data'], meta['args'], {
                headers: req.headers
            });
            // rpc_processor.process(ctx, (ctx) => {
            //   console.log(ctx);
            //   // res.write(response);
            //   // res.end();
            // });
            try {
                const response = yield this.callMethod(ctx);
                const buffer = Buffer.from(response);
                res.writeHead(200);
                res.write(buffer.toString("binary"));
                res.end();
            }
            catch (e) {
                const error = typeof this.errorHandler === "function" ? yield this.errorHandler(e) : {
                    code: 400,
                    message: e.message || 'Unhandled error',
                    error: e
                };
                res.writeHead(error.code);
                res.write(JSON.stringify(error));
                res.end();
            }
        }));
        req.pipe(busboy);
    }
    enableCors(req, res) {
        // Website you wish to allow to connect
        res.setHeader('Access-Control-Allow-Origin', '*');
        // Request methods you wish to allow
        res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
        // Request headers you wish to allow
        res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,authorization,content-type');
        // Set to true if you need the website to include cookies in the requests sent
        // to the API (e.g. in case you use sessions)
        res.setHeader('Access-Control-Allow-Credentials', 'true');
    }
    callMethod(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._runInterceptors(ctx);
            yield this._decodeRequest(ctx);
            yield this._callMethod(ctx);
            return this._encodeResponse(ctx);
        });
    }
    _runInterceptors(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { class_interceptors, method_interceptors } = yield this._getMethodMetadata(ctx.raw.class, ctx.raw.method);
            for (let { identifier } of [...class_interceptors, ...method_interceptors]) {
                const ClassCtor = this.implementations[identifier];
                const instance = new ClassCtor(ctx);
                yield instance.intercept();
            }
        });
    }
    _decodeRequest(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { class: class_name, method: method_name, state, args } = ctx.raw;
            const ClassDataType = yield this._getDataType(class_name);
            const RequestType = yield this._getRequestType(class_name, method_name);
            const decoded_args = this.decode(RequestType, args);
            const decoded_data = ClassDataType && state ? this.decode(ClassDataType, state) : undefined;
            ctx.request_body = { args: decoded_args, data: decoded_data };
            return ctx.request_bod;
        });
    }
    decode(type, data) {
        return type.toObject(type.decode(data), {
            enums: String,
            longs: Number,
            bytes: String,
            defaults: true,
            arrays: true,
            objects: true,
            oneofs: true // includes virtual oneof fields set to the present field's name
        });
    }
    _callMethod(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { class: class_name, method: method_name } = ctx.raw;
            const { args, data } = ctx.request_body;
            const { isReturnTypeClass } = yield this._getMethodMetadata(class_name, method_name);
            const _args = [];
            const method_arguments = yield this._getArgumentTypes(class_name, method_name);
            method_arguments.forEach(({ identifier, index }) => _args[index] = args[identifier]);
            const ClassCtor = this.implementations[class_name];
            const instance = new ClassCtor(data);
            instance.getCtx = () => ctx;
            const _return = yield instance[method_name](..._args);
            ctx.response_body = {
                class_data: instance.getData && instance.getData() || {},
                response: isReturnTypeClass()
                    ? Array.isArray(_return)
                        ? _return.map((instance) => instance.getData ? instance.getData() : {})
                        : _return.getData ? _return.getData() : {}
                    : _return
            };
            return ctx.response_body;
        });
    }
    _encodeResponse(ctx) {
        return __awaiter(this, void 0, void 0, function* () {
            const { class: class_name, method: method_name } = ctx.raw;
            const { response, class_data } = ctx.response_body;
            const ReturnType = yield this._getReturnType(class_name, method_name);
            const _return = {};
            if (response)
                _return["response"] = response;
            if (class_data)
                _return["data"] = class_data;
            // 1. Verify data
            const errMsg = ReturnType.verify(_return);
            if (errMsg)
                throw Error(errMsg);
            // 2. encode protobuf
            // Create a new message
            // or use .fromObject if conversion is necessary
            const message = ReturnType.create(_return);
            // Encode a message to an Uint8Array (browser) or Buffer (node)
            return ReturnType.encode(message).finish();
        });
    }
    _getArgumentTypes(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { request_type } = yield this._getMethodMetadata(class_name, method_name);
            return request_type.args;
        });
    }
    _getRequestType(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { request_type } = yield this._getMethodMetadata(class_name, method_name);
            const type = this.root.lookupType(request_type.proto);
            if (!type)
                throw Error('Method not found');
            return type;
        });
    }
    _getReturnType(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { return_type } = yield this._getMethodMetadata(class_name, method_name);
            const type = this.root.lookupType(return_type.proto);
            if (!type)
                throw Error('Return type not found');
            return type;
        });
    }
    _getMethodMetadata(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = this.map[class_name]['methods'][method_name];
            const return_type = metadata['return_type'];
            const request_type = metadata['request_type'];
            const method_interceptors = metadata['interceptors'] || [];
            const class_interceptors = this.map[class_name]['interceptors'] || [];
            return {
                class_interceptors,
                method_interceptors,
                metadata,
                request_type,
                return_type,
                return_proto_type: return_type.proto,
                return_constructor_type: return_type.ctor,
                isReturnTypeClass: () => {
                    return return_type.datatype === 'class';
                }
            };
        });
    }
    _getDataType(class_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const DataType = this.map[class_name]['proto_class_data_type'];
            if (!DataType)
                return;
            return this.root.lookupType(DataType);
        });
    }
}
var drive;
(function (drive) {
    class AuthService {
        constructor(data) { this.$___class_state = data; }
        getCtx() { }
        getData() { return this.$___class_state; }
        updateData(data) { Object.assign(this.$___class_state, data); }
    }
    drive.AuthService = AuthService;
    class AuthServiceSrpc extends SrpcServer {
        constructor(classes) {
            super(classes);
        }
    }
    drive.AuthServiceSrpc = AuthServiceSrpc;
    class SecureClass {
        constructor(ctx) {
            this.ctx = ctx;
        }
    }
    drive.SecureClass = SecureClass;
    class DriveFile {
        constructor(data) { this.$___class_state = data; }
        getCtx() { }
        getData() { return this.$___class_state; }
        updateData(data) { Object.assign(this.$___class_state, data); }
    }
    drive.DriveFile = DriveFile;
    class DriveService {
        constructor(data) { this.$___class_state = data; }
        getCtx() { }
        getData() { return this.$___class_state; }
        updateData(data) { Object.assign(this.$___class_state, data); }
    }
    drive.DriveService = DriveService;
    class DriveServiceSrpc extends SrpcServer {
        constructor(classes) {
            super(classes);
        }
    }
    drive.DriveServiceSrpc = DriveServiceSrpc;
})(drive = exports.drive || (exports.drive = {}));
