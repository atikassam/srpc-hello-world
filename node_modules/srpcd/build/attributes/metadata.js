"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.metadata = void 0;
const symbolType_1 = require("../core/symbolType");
function createDataMetadata(identifier, properties = new Map()) {
    return {
        type: symbolType_1.SymbolType.DATA,
        identifier,
        properties,
        _create({ file }) {
            for (let property of this.properties.values())
                property._create({ file, data: this });
        }
    };
}
const builtins = {
    data: new Map()
        .set('EmptyClassData', createDataMetadata('EmptyClassData')),
    classes: new Map(),
};
exports.metadata = {
    Program(t1, t2, t3, t4) {
        const declarations = new Map();
        for (let metadata of [...t4.metadata, ...Array.from(builtins.data.values())])
            declarations.set(metadata.identifier, metadata);
        for (const meta of t4.metadata)
            declarations.set(meta.identifier, meta);
        const file_meta = {
            version: t1.sourceString,
            package: t2.sourceString,
            declarations,
            _create() {
                for (let declaration of this.declarations.values())
                    declaration._create({ file: this });
            }
        };
        file_meta._create();
        return file_meta;
    },
    ImportElements(t1, ...t2) { },
    ImportDeclaration(t1, t2, ...t3) { },
    DataDeclaration(t1, identifier, t3, dataBody, t5) {
        const properties = new Map();
        for (let metadata of dataBody.metadata)
            properties.set(metadata.identifier, metadata);
        return {
            type: symbolType_1.SymbolType.DATA,
            identifier: identifier.sourceString,
            properties,
            _create({ file }) {
                for (let property of this.properties.values())
                    property._create({ file, data: this });
            }
        };
    },
    DataProperty(identifier, t2, datatype) {
        return {
            identifier: identifier.sourceString,
            datatype: datatype.metadata,
            _create({ file }) {
                this.datatype._create({ file });
            }
        };
    },
    InterceptedMethod(t1, t2, ...t3) {
        const interceptors = new Map();
        for (let metadata of t1.metadata)
            interceptors.set(metadata.identifier, metadata);
        return Object.assign(Object.assign({}, t2.metadata), { interceptors, _create({ file }) {
                var _a;
                for (let metadata of ((_a = this.interceptors) === null || _a === void 0 ? void 0 : _a.values()) || [])
                    metadata._create({ file });
                t2.metadata._create({ file });
            } });
    },
    InterceptedServiceClassDeclaration(t1, t2, ...t3) {
        const interceptors = new Map();
        for (let metadata of t1.metadata)
            interceptors.set(metadata.identifier, metadata);
        return Object.assign(Object.assign({}, t2.metadata), { interceptors, _create({ file }) {
                var _a;
                for (let metadata of ((_a = this.interceptors) === null || _a === void 0 ? void 0 : _a.values()) || [])
                    metadata._create({ file });
                t2.metadata._create({ file });
            } });
    },
    InterceptedClassDeclaration(t1, t2, ...t3) {
        const interceptors = new Map();
        for (let metadata of t1.metadata)
            interceptors.set(metadata.identifier, metadata);
        return Object.assign(Object.assign({}, t2.metadata), { interceptors, _create({ file }) {
                var _a;
                for (let metadata of ((_a = this.interceptors) === null || _a === void 0 ? void 0 : _a.values()) || [])
                    metadata._create({ file });
                t2.metadata._create({ file });
            } });
    },
    InterceptorCall(t1, t2, t3, t4, ...t5) {
        return {
            identifier: t2.sourceString,
            _create({ file }) {
                this.reference = file.declarations.get(this.identifier);
            }
        };
    },
    InterceptorDeclaration(t1, t2, t3, ...t4) {
        return {
            type: symbolType_1.SymbolType.INTERCEPTOR,
            identifier: t2.sourceString,
            arguments: t3.metadata,
            _create({ file }) {
                for (let property of this.arguments.values())
                    property._create({ file, interceptor: this });
            }
        };
    },
    InterceptorArgs(t1, formalParameterList, t3, ...t4) {
        return formalParameterList.metadata;
    },
    ServiceClassDeclaration(t1, t2, ...t3) {
        return Object.assign(Object.assign({}, t2.metadata), { isService: true });
    },
    ClassDeclaration(t1, identifier, t3, classBody, t5) {
        const properties = new Map();
        for (let metadata of classBody.metadata)
            properties.set(metadata.identifier, metadata);
        return {
            type: symbolType_1.SymbolType.CLASS,
            identifier: identifier.sourceString,
            properties,
            _create({ file }) {
                for (let property of this.properties.values())
                    property._create({ file, class: this });
            }
        };
    },
    ClassBody(t1, t2, ...t3) {
        const props = [...t1.metadata, ...t2.metadata];
        const data_prop = props.find(f => f.type === symbolType_1.SymbolType.DATA);
        if (!data_prop)
            props.push({
                identifier: '$___class_state',
                type: symbolType_1.SymbolType.DATA,
                datatype: {
                    identifier: '$___class_state',
                    repeated: false,
                    type: 'null',
                    is_reference: true,
                    ctor: 'EmptyClassData',
                    _create({ file }) {
                        const ctor = file.declarations.get(this.ctor);
                        if (ctor) {
                            this.type = ctor.type;
                            this.reference = ctor;
                        }
                    }
                },
                _create({ file, }) {
                    this.datatype._create({ file });
                }
            });
        return props;
    },
    ClassData(state, datatype, ...t3) {
        return {
            identifier: '$___class_state',
            type: symbolType_1.SymbolType.DATA,
            datatype: datatype.metadata,
            _create({ file, }) {
                this.datatype._create({ file });
            }
        };
    },
    ClassMethod(identifier, classMethodArgs, t3, datatype) {
        return {
            type: symbolType_1.SymbolType.FUNCTION,
            identifier: identifier.sourceString,
            return: datatype.metadata,
            arguments: classMethodArgs.metadata,
            _create({ file, class: _class }) {
                for (let property of this.arguments.values())
                    property._create({ file, class: _class, method: this });
                this.return._create({ file });
            }
        };
    },
    ClassMethodArgs(t1, formalParameterList, t3, ...t4) {
        return formalParameterList.metadata;
    },
    FormalParameterList(formalParameter) {
        const parameters = new Map();
        formalParameter.asIteration().children.forEach((c, index, array) => {
            parameters.set(index, c.metadata);
        });
        return parameters;
    },
    FormalParameter(identifier, t2, datatype) {
        return {
            identifier: identifier.sourceString,
            datatype: datatype.metadata,
            _create({ file, class: _class, method }) {
                this.datatype._create({ file });
            }
        };
    },
    Datatype(t1, ...t2) {
        return Object.assign({ _create(meta) { } }, t1.metadata);
    },
    referenceName(t1, t2, ...t3) {
        return {
            identifier: '',
            repeated: false,
            type: 'null',
            is_reference: true,
            ctor: this.sourceString,
            _create({ file }) {
                const ctor = file.declarations.get(this.ctor);
                if (ctor) {
                    this.type = ctor.type;
                    this.reference = ctor;
                }
            }
        };
    },
    builtindatatype(t1, ...t2) {
        return {
            type: t1.sourceString
        };
    },
    ArrayType(t1, t2, t3, ...t4) {
        return Object.assign(Object.assign({}, (t1.metadata || {})), { repeated: true });
    },
};
