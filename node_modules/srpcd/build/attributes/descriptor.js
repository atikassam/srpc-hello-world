"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.descriptor = void 0;
const path = require("path");
const types_1 = require("./helpers/types");
const helper_1 = require("./helpers/helper");
const VariableDescriptor_1 = require("./helpers/VariableDescriptor");
const InterceptorDescriptor_1 = require("./helpers/InterceptorDescriptor");
const PackageDescriptor_1 = require("./helpers/PackageDescriptor");
const DataTypeDescriptor_1 = require("./helpers/DataTypeDescriptor");
const FunctionDescriptor_1 = require("./helpers/FunctionDescriptor");
const DataDescriptor_1 = require("./helpers/DataDescriptor");
const ClassDescriptor_1 = require("./helpers/ClassDescriptor");
const InterceptorCallDescriptor_1 = require("./helpers/InterceptorCallDescriptor");
const ProgramDescriptor_1 = require("./helpers/ProgramDescriptor");
const descriptor = (entry, is_root_file, semantics, _program) => {
    const { dir, base, ext, } = path.parse(entry);
    const program = _program || new ProgramDescriptor_1.ProgramDescriptor(entry, null);
    if (!_program)
        program.semantics = semantics;
    return ({
        Program(_package, imports, declarations) {
            return __awaiter(this, void 0, void 0, function* () {
                if (program.compiledFiles.has(entry))
                    return program.compiledFiles.get(entry);
                const file = new ProgramDescriptor_1.ProgramDescriptor(entry, this);
                file.is_root_file = is_root_file;
                file.semantics = semantics;
                program.compiledFiles.set(file.identifier, file);
                // file.version = version.sourceString;
                file.package = yield _package.descriptor;
                file.filename = entry;
                for (let _descriptor of yield Promise.all(declarations.descriptor))
                    file.children.add(_descriptor);
                for (let _import of yield Promise.all(imports.descriptor))
                    file.imports.set(_import.identifier, _import);
                program.children.add(file);
                return file;
            });
        },
        PackageExpression(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                return PackageDescriptor_1.PackageDescriptor.getPackage({ identifier: t2.sourceString }) || new PackageDescriptor_1.PackageDescriptor(t2.sourceString, t2);
            });
        },
        ImportDeclaration(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                const importpath = t2.sourceString;
                return yield helper_1.importDeclaration(entry, importpath, t2, program);
            });
        },
        DataDeclaration(t1, identifier, t3, dataBody, t5) {
            return __awaiter(this, void 0, void 0, function* () {
                const declaration = new DataDescriptor_1.DataDescriptor(identifier.sourceString, this);
                for (const descriptor of yield Promise.all(dataBody.descriptor))
                    declaration.children.add(descriptor);
                return declaration;
            });
        },
        DataProperty(identifier, t2, datatype) {
            return __awaiter(this, void 0, void 0, function* () {
                const declaration = new VariableDescriptor_1.VariableDescriptor(identifier.sourceString, this);
                declaration.datatype = yield datatype.descriptor;
                declaration.datatype.allowed_types = new Set(types_1.PropertyTypes);
                return declaration;
            });
        },
        InterceptedMethod(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = yield t2.descriptor;
                for (let _descriptor of yield Promise.all(t1.descriptor))
                    descriptor.interceptors.set(_descriptor.identifier, _descriptor);
                return descriptor;
            });
        },
        InterceptedServiceClassDeclaration(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = yield t2.descriptor;
                for (let _descriptor of yield Promise.all(t1.descriptor))
                    descriptor.interceptors.set(_descriptor.identifier, _descriptor);
                return descriptor;
            });
        },
        InterceptedClassDeclaration(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = yield t2.descriptor;
                for (let _descriptor of yield Promise.all(t1.descriptor))
                    descriptor.interceptors.set(_descriptor.identifier, _descriptor);
                return descriptor;
            });
        },
        InterceptorCall(t1, referenceName, t3, t4, ...t5) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new InterceptorCallDescriptor_1.InterceptorCallDescriptor(referenceName.sourceString, referenceName);
                descriptor.datatype = yield referenceName.descriptor;
                descriptor.datatype.allowed_types = new Set([types_1.SymbolType.INTERCEPTOR]);
                return descriptor;
            });
        },
        InterceptorDeclaration(t1, t2, args, ...t4) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new InterceptorDescriptor_1.InterceptorDescriptor(t2.sourceString, this);
                descriptor.parameters = yield args.descriptor;
                return descriptor;
            });
        },
        InterceptorArgs(t1, formalParameterList, t3, ...t4) {
            return __awaiter(this, void 0, void 0, function* () {
                return formalParameterList.descriptor;
            });
        },
        ServiceClassDeclaration(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = yield t2.descriptor;
                descriptor.modifiers.add(types_1.ClassModifier.SERVICE);
                return descriptor;
            });
        },
        ClassDeclaration(t1, identifier, t3, classBody, t5) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new ClassDescriptor_1.ClassDescriptor(identifier.sourceString, this);
                for (let declaration of yield classBody.descriptor)
                    descriptor.children.add(declaration);
                return descriptor;
            });
        },
        ClassBody(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                let [data] = yield Promise.all(t1.descriptor);
                if (!data) {
                    data = new VariableDescriptor_1.VariableDescriptor('$___class_state', t1);
                    data.datatype = new DataTypeDescriptor_1.DataTypeDescriptor('EmptyClassData', t1);
                    data.datatype.type = types_1.SymbolType.REFERENCE;
                    data.datatype.allowed_types = new Set([types_1.SymbolType.DATA]);
                }
                return [data, ...yield Promise.all(yield t2.descriptor)];
            });
        },
        ClassData(state, datatype, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new VariableDescriptor_1.VariableDescriptor('$___class_state', this);
                descriptor.datatype = yield datatype.descriptor;
                descriptor.datatype.allowed_types = new Set([types_1.SymbolType.DATA]);
                return descriptor;
            });
        },
        ClassMethod(identifier, classMethodArgs, t3, datatype) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new FunctionDescriptor_1.FunctionDescriptor(identifier.sourceString, this);
                descriptor.return_type = yield datatype.descriptor;
                descriptor.return_type.allowed_types = new Set(types_1.ReturnTypes);
                descriptor.parameters = yield classMethodArgs.descriptor;
                return descriptor;
            });
        },
        ClassMethodArgs(t1, formalParameterList, t3, ...t4) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield formalParameterList.descriptor;
            });
        },
        FormalParameterList(formalParameter) {
            return __awaiter(this, void 0, void 0, function* () {
                const parameters = new Map();
                let index = 0;
                for (const c of formalParameter.asIteration().children) {
                    parameters.set(index, yield c.descriptor);
                    index++;
                }
                return parameters;
            });
        },
        FormalParameter(identifier, t2, datatype) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new VariableDescriptor_1.VariableDescriptor(identifier.sourceString, this);
                descriptor.datatype = yield datatype.descriptor;
                descriptor.datatype.allowed_types = new Set(types_1.PropertyTypes);
                return descriptor;
            });
        },
        Datatype(t1, ...t2) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield t1.descriptor;
            });
        },
        referenceName(t1, t2, ...t3) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new DataTypeDescriptor_1.DataTypeDescriptor(this.sourceString, this);
                descriptor.type = types_1.SymbolType.REFERENCE;
                return descriptor;
            });
        },
        builtindatatype(t1, ...t2) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = new DataTypeDescriptor_1.DataTypeDescriptor(t1.sourceString, this);
                descriptor.type = t1.sourceString;
                return descriptor;
            });
        },
        ArrayType(t1, t2, t3, ...t4) {
            return __awaiter(this, void 0, void 0, function* () {
                const descriptor = yield t1.descriptor;
                descriptor.repeated = true;
                return descriptor;
            });
        },
    });
};
exports.descriptor = descriptor;
