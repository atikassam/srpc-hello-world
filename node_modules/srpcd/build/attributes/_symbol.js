"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._symbol = exports._GLOBAL_SCOPE_ = void 0;
const symbolTable_1 = require("../core/symbolTable");
const symbolType_1 = require("../core/symbolType");
exports._symbol = {
    Program(t1, t2, t3, t4) {
        const scope = new symbolTable_1.SymbolTable(this.metedata, (scope, parent, global) => {
            scope.setGlobalScope(scope);
            scope.insert('class', symbolType_1.SymbolType.CLASS);
            scope.insert('data', symbolType_1.SymbolType.DATA);
            scope.insert('int', symbolType_1.SymbolType.INT);
            scope.insert('string', symbolType_1.SymbolType.STRING);
            scope.insert('boolean', symbolType_1.SymbolType.BOOLEAN);
            for (let child_scope of t4._symbol) {
                if (!child_scope)
                    continue;
                child_scope.setParentScope(scope);
            }
        });
        scope.build();
        exports._GLOBAL_SCOPE_ = scope;
        return scope;
    },
    DataDeclaration(t1, identifier, t3, dataBody, t5) {
        const data_prop = identifier.sourceString;
        const data_type = t1.sourceString;
        return new symbolTable_1.SymbolTable(this.metadata, (scope, parent, global) => {
            if (global.lookup(data_prop))
                throw new Error('Duplicate data structure ' + +'\n' +
                    identifier.source.getLineAndColumnMessage());
            global.insert(data_prop, data_type);
            for (let child_scope of dataBody._symbol) {
                child_scope.setParentScope(scope);
            }
        });
    },
    DataProperty(identifier, t2, datatype) {
        const prop_name = identifier.sourceString;
        const prop_type = datatype.sourceString;
        return new symbolTable_1.SymbolTable(this.metedata, (scope, parent, global) => {
            if (parent === null || parent === void 0 ? void 0 : parent.lookup(prop_name))
                throw new Error('Duplicate property ' + prop_name + '\n' +
                    identifier.source.getLineAndColumnMessage());
            parent === null || parent === void 0 ? void 0 : parent.insert(prop_name, prop_type);
        });
    },
    InterceptedMethod(t1, t2, ...t3) {
        return t2._symbol;
    },
    InterceptedServiceClassDeclaration(t1, t2, ...t3) {
        return t2._symbol;
    },
    InterceptedClassDeclaration(t1, t2, ...t3) {
        return t2._symbol;
    },
    InterceptorCall(t1, t2, t3, t4, ...t5) {
        return t2._symbol;
    },
    InterceptorDeclaration(t1, t2, t3, ...t4) { },
    InterceptorArgs(t1, t2, t3, ...t4) { },
    ServiceClassDeclaration(t1, t2, ...t3) {
        return t2._symbol;
    },
    ClassDeclaration(t1, identifier, t3, classBody, t5) {
        const class_name = identifier.sourceString;
        const class_type = t1.sourceString;
        return new symbolTable_1.SymbolTable(this.metadata, (scope, parent, global) => {
            if (global.lookup(class_name))
                throw new Error('Duplicate class ' + class_name + '\n' +
                    identifier.source.getLineAndColumnMessage());
            global.insert(class_name, class_type);
            for (let child_scope of classBody._symbol) {
                child_scope.setParentScope(scope);
            }
        });
    },
    ClassBody(t1, t2, ...t3) {
        return [...t1._symbol, ...t2._symbol]; //.filter(console.log)
    },
    ClassData(t1, t2, ...t3) {
        return new symbolTable_1.SymbolTable(this.metedata, (scope, parent, global) => {
            parent === null || parent === void 0 ? void 0 : parent.insert(this.metadata.identifier, symbolType_1.SymbolType.DATA);
        });
    },
    ClassMethod(identifier, classMethodArgs, t3, datatype) {
        const method_name = identifier.sourceString;
        return new symbolTable_1.SymbolTable(this.metedata, (scope, parent, global) => {
            if (parent === null || parent === void 0 ? void 0 : parent.lookup(method_name))
                throw new Error('Duplicate method ' + method_name + '\n' +
                    identifier.source.getLineAndColumnMessage());
            parent === null || parent === void 0 ? void 0 : parent.insert(identifier.sourceString, symbolType_1.SymbolType.FUNCTION);
        });
    },
};
