import * as protobufjs from 'protobufjs/light'
import axios from "axios";
import * as FormData from "form-data";
import {Buffer} from "buffer";
interface EmptyClassData {}
class RpcServices {
  protected ___class_ctors = {};
  constructor(protected ___client: RpcClient) {}
  public async _createInstance(class_name, state: any) {
    const _services: any = this
    const ClassName = _services.___class_ctors[class_name];

    const instance = new ClassName(state);
    instance.__rpc_client = this.___client;
    instance.__updateData && instance.__updateData(state);
    return instance;
  }
}

class RpcClient<Service = undefined, ServicesType extends RpcServices = RpcServices> {
  protected services!: ServicesType;
  private _map?: MetadataSchema;
  private _root?: protobufjs.Root;
  private get map() {
    if (!this._map) throw Error('Please initiate the app first')
    return this._map;
  };
  private get root() {
    if (!this._root) throw Error('Please initiate the app first')
    return this._root;
  };

  constructor(protected url: string, protected headers: any, protected Services: any) {}

  async init(): Promise<Service> {
    this._map = await require('./def.map.json');
    this._root = await protobufjs.Root.fromJSON(require('./def.proto.json'));

    if (!this.services) this.services = new this.Services(this);
    return undefined as any
  }

  async callMethod(instance: any, class_name: any, method_name: any, args: any) {
    const encoded = await this._encodeRequest(instance, class_name, method_name, args)
    const response = await this._callMethod(instance, class_name, method_name, encoded.data, encoded.args)
    return this._decodeResponse(instance, class_name, method_name, response)
  }

  private async _decodeResponse(instance, class_name, method_name, _response) {
    const ReturnType = await this._getReturnType(class_name, method_name);
    const { isReturnTypeClass, return_type } = await this._getMethodMetadata(class_name, method_name);

    const message = ReturnType.decode(_response) as any;
    const { data, response } = ReturnType.toObject(message, {
      enums: String,  // enums as string names
      longs: Number,  // longs as strings (requires long.js)
      bytes: String,  // bytes as base64 encoded strings
      defaults: true, // includes default values
      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
      objects: true,  // populates empty objects (map fields) even if defaults=false
      oneofs: true    // includes virtual oneof fields set to the present field's name
    }) as any;
    instance.__updateData && instance.__updateData(data);

    if (isReturnTypeClass()) {
      return Array.isArray(response)
        ? Promise.all(response.map((state) => this.services._createInstance(return_type.ctor, state)))
        : await this.services._createInstance(return_type.ctor, response);
    }

    return response;
  }

  private async _callMethod(instance: any, class_name, method_name, data, args) {
    const form = new FormData();
    form.append('args', args, { filename: 'args' });
    data && form.append('data', data, { filename: 'data' });
    form.append('method', method_name);
    form.append('class', class_name);


    try {
      const request = await axios.post(this.url, form, {
        responseType: "arraybuffer",
        headers: { 'content-type': `multipart/form-data; boundary=${form.getBoundary()}` }
      });

      return Buffer.from(request.data, "binary");
    } catch (e) {
      throw e.response && e.response.data && e.response.data || e;
    }
  }

  private async _encodeRequest(instance, class_name, method_name, args: any[]) {
    const RequestType = await this._getRequestType(class_name, method_name);
    const ClassDataType = await this._getDataType(class_name);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    const method_args: any = { };
    const method_arguments = await this._getArgumentTypes(class_name, method_name);
    (method_arguments || []).forEach(({ index, identifier }) => {
      method_args[identifier] = args[index];
    })

    const encoded = {
      args: await this._encodeWithType(RequestType, method_args),
      data: undefined
    };

    if (ClassDataType) {
      encoded['data'] = await this._encodeWithType(ClassDataType, instance.getData())
    }

    return encoded;
  }

  private async _encodeWithType(type, data) {
    if (!data) return;

    // 1. Verify data
    const errMsg = type.verify(data);
    if (errMsg) throw Error(errMsg);

    // 2. encode protobuf
    // Create a new message// or use .fromObject if conversion is necessary
    const message = type.create(data);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    return  type.encode(message).finish();
  }

  private async _getArgumentTypes(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    return request_type.args;
  }

  private async _getRequestType(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(request_type.proto);
    if (!type) throw Error('Method not found')
    return type
  }

  private async _getReturnType(class_name, method_name): Promise<protobuf.Type> {
    const { return_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(return_type.proto);
    if (!type) throw Error('Return type not found')
    return type
  }

  private async _getMethodMetadata(class_name, method_name) {
    const metadata = this.map[class_name]['methods'][method_name];
    const return_type = metadata['return_type'];
    const request_type = metadata['request_type'];

    return {
      metadata,
      request_type,
      return_type,
      return_proto_type: return_type.proto,
      return_constructor_type: return_type.ctor,
      isReturnTypeClass: () => {
        return return_type.datatype === 'class'
      }
    }
  }

  private async _getDataType(class_name): Promise<protobuf.Type | undefined> {
    const DataType = this.map[class_name]['proto_class_data_type'];
    if (!DataType) return;
    return this.root.lookupType(DataType);
  }
}

interface MetadataSchemaClassType {
  [method: string]: {
    request_type: {
      proto: string,
      constructor: string
      args: { index: number, identifier: string }[],
    },
    return_type: {
      proto: string,
      ctor: string
      datatype: string
    },
  }
}

interface MetadataSchema {
  [data_or_class_name: string]: {
    methods: MetadataSchemaClassType
  }
}