import * as protobufjs from 'protobufjs'
import * as http from "http";
import * as Busboy from "busboy";
import {IncomingMessage, ServerResponse} from "http";
import * as buffer from "buffer";
// import * as express from "express";

export interface SrpcServerOptions {
  enable_cors: boolean
}

interface RpcProcessCtx {
  rpc_processor: RpcProcessor,
  protocol: 'http',
  headers: any,
  raw: {
    class: string,
    method: string,
    state: protobufjs.Buffer,
    args: protobufjs.Buffer
  },
  protobuf: protobufjs.Root,
  def_map: any,
  [key: string]: any
}

const last = a => a[a.length - 1]
const reduce = a => a.slice(0, -1)

class RpcProcessor {
  private def_map = require('./def.map.json');
  private root = protobufjs.Root.fromJSON(require('./def.proto.json'));

  createCtx(_class, _method, _state, _args, _opts: { headers }):  RpcProcessCtx {
    return {
      headers: _opts.headers,
      rpc_processor: this,
      protocol: 'http',
      raw: {
        class: _class,
        method: _method,
        state: _state,
        args: _args
      },
      protobuf: this.root,
      def_map: this.def_map,
    }
  }

  use(method) {
    this.process = ((stack) => (...args) => stack(...reduce(args), () => {
      const next = last(args)
      method.apply(this, [...reduce(args), next.bind.apply(next, [null, ...reduce(args)])])
    }))(this.process)
  }

  process(...args) {
    last(args).apply(this, reduce(args))
  }
}

function init() {}
function decodeRequest() {}
function validateRequest() {}
function encodeRequest() {}
function validateResponse() {}
function callMethod() {}

const rpc_processor = new RpcProcessor();
rpc_processor.use(init);
rpc_processor.use(decodeRequest);
rpc_processor.use(validateRequest);
rpc_processor.use(callMethod);
rpc_processor.use(validateResponse);
rpc_processor.use(encodeRequest);

export type RpcErrorHandler = (e: any) => Promise<{
  code: number,
  message: string,
  error: any
}>

class SrpcServer<SrpcClasses> {
  private options?: SrpcServerOptions;
  private _map?: any;
  private _root?: protobufjs.Root;
  private errorHandler?: RpcErrorHandler
  private get map() {
    if (!this._map) throw Error('Please initiate the app first')
    return this._map;
  };

  private get root() {
    if (!this._root) throw Error('Please initiate the app first')
    return this._root;
  };

  constructor(private implementations: SrpcClasses) {
    this.init()
  }

  setErrorHandler(fnc: RpcErrorHandler) {
    this.errorHandler = fnc;

    return this;
  }

  private async init() {
    this._map = await require('./def.map.json');
    this._root = await protobufjs.Root.fromJSON(require('./def.proto.json'));

    return this;
  }

  createServer(options?: { enable_cors: boolean }) {
    return http.createServer((req, res) => {
      if (options?.enable_cors) this.enableCors(req, res);
      if (req.method?.toLowerCase() === 'OPTIONS'.toLowerCase()) return res.writeHead(200).end();
      if (req.method?.toLowerCase() !== 'POST'.toLowerCase()) return res.writeHead(405).end();

      this.requestHandler(req, res);
    })
  }

  public useExpressHandler = (req: IncomingMessage, res: ServerResponse) => {
    return this.requestHandler(req, res);
  }

  public useKoaHandler = (ctx: { req: IncomingMessage, res: ServerResponse }) => {
    return this.requestHandler(ctx.req, ctx.res);
  }

  private requestHandler(req: IncomingMessage, res: ServerResponse) {
    const meta: any = {}, busboy = new Busboy({headers: req.headers});

    busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {
      const buf: any[] = [];
      file.on('data',  (data) => buf.push(data));
      file.on('end', () => meta[fieldname] = Buffer.concat(buf));
    });

    busboy.on('field', function (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) {
      meta[fieldname] = val;
    });
    busboy.on('finish', async  () => {
      const ctx = rpc_processor.createCtx(meta['class'], meta['method'], meta['data'], meta['args'], {
        headers: req.headers
      })

      // rpc_processor.process(ctx, (ctx) => {
      //   console.log(ctx);
      //   // res.write(response);
      //   // res.end();
      // });

      try {
        const response = await this.callMethod(ctx);
        const buffer = Buffer.from(response);

        res.writeHead(200);
        res.write(buffer.toString("binary"));
        res.end();
      } catch (e) {
        const error = typeof this.errorHandler === "function" ? await this.errorHandler(e) : {
          code: 400,
          message: e.message || 'Unhandled error',
          error: e
        }

        res.writeHead(error.code);
        res.write(JSON.stringify(error));
        res.end()
      }
    });
    req.pipe(busboy);
  }

  private enableCors(req: IncomingMessage, res: ServerResponse) {
    // Website you wish to allow to connect
    res.setHeader('Access-Control-Allow-Origin', '*');

    // Request methods you wish to allow
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');

    // Request headers you wish to allow
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,authorization,content-type');

    // Set to true if you need the website to include cookies in the requests sent
    // to the API (e.g. in case you use sessions)
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }

  protected async callMethod(ctx: RpcProcessCtx) {
    await this._runInterceptors(ctx);
    await this._decodeRequest(ctx);
    await this._callMethod(ctx);
    return this._encodeResponse(ctx);
  }

  private async _runInterceptors(ctx: RpcProcessCtx) {
    const { class_interceptors, method_interceptors } = await this._getMethodMetadata(ctx.raw.class, ctx.raw.method);

    for (let { identifier } of [ ...class_interceptors, ...method_interceptors ]) {
      const ClassCtor = (this.implementations as any)[identifier];
      const instance = new ClassCtor(ctx);
      await instance.intercept()
    }
  }

  private async _decodeRequest(ctx: RpcProcessCtx) {
    const { class: class_name, method: method_name, state, args } = ctx.raw;

    const ClassDataType = await this._getDataType(class_name);
    const RequestType = await this._getRequestType(class_name, method_name);
    const decoded_args: any = this.decode(RequestType, args);

    const decoded_data: any = ClassDataType && state ? this.decode(ClassDataType, state) : undefined;

    ctx.request_body = { args: decoded_args, data: decoded_data };
    return ctx.request_bod;
  }

  private decode(type, data) {
    return type.toObject(type.decode(data), {
      enums: String,  // enums as string names
      longs: Number,  // longs as strings (requires long.js)
      bytes: String,  // bytes as base64 encoded strings
      defaults: true, // includes default values
      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
      objects: true,  // populates empty objects (map fields) even if defaults=false
      oneofs: true    // includes virtual oneof fields set to the present field's name
    }) as any;
  }

  private async _callMethod(ctx: RpcProcessCtx) {
    const { class: class_name, method: method_name } = ctx.raw
    const { args, data } = ctx.request_body;
    const { isReturnTypeClass } = await this._getMethodMetadata(class_name, method_name);

    const _args: any[] = [];
    const method_arguments = await this._getArgumentTypes(class_name, method_name);
    method_arguments.forEach(({ identifier, index }) => _args[index] = args[identifier]);

    const ClassCtor = (this.implementations as any)[class_name];
    const instance = new ClassCtor(data);
    instance.getCtx = () => ctx;

    const _return =  await instance[method_name](..._args);

    ctx.response_body = {
      class_data: instance.getData && instance.getData() || {},
      response: isReturnTypeClass()
        ? Array.isArray(_return)
          ? _return.map((instance) => instance.getData ? instance.getData() : {})
          : _return.getData ? _return.getData() : {}
        : _return
    };

    return ctx.response_body;
  }

  private async _encodeResponse(ctx) {
    const { class: class_name, method: method_name } = ctx.raw;
    const { response, class_data } = ctx.response_body;
    const ReturnType = await this._getReturnType(class_name, method_name);

    const _return: { data?, response? } = {};
    if (response) _return["response"] = response;
    if (class_data) _return["data"] = class_data;

    // 1. Verify data
    const errMsg = ReturnType.verify(_return);
    if (errMsg) throw Error(errMsg);

    // 2. encode protobuf
    // Create a new message
    // or use .fromObject if conversion is necessary
    const message = ReturnType.create(_return);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    return ReturnType.encode(message).finish();
  }

  private async _getArgumentTypes(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    return request_type.args;
  }

  private async _getRequestType(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);

    const type = this.root.lookupType(request_type.proto);
    if (!type) throw Error('Method not found')
    return type
  }

  private async _getReturnType(class_name, method_name): Promise<protobuf.Type> {
    const { return_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(return_type.proto);
    if (!type) throw Error('Return type not found')
    return type
  }

  private async _getMethodMetadata(class_name, method_name) {
    const metadata = this.map[class_name]['methods'][method_name];
    const return_type = metadata['return_type'];
    const request_type = metadata['request_type'];
    const method_interceptors = metadata['interceptors'] || [];
    const class_interceptors = this.map[class_name]['interceptors'] || [];

    return {
      class_interceptors,
      method_interceptors,
      metadata,
      request_type,
      return_type,
      return_proto_type: return_type.proto,
      return_constructor_type: return_type.ctor,
      isReturnTypeClass: () => {
        return return_type.datatype === 'class'
      }
    }
  }

  private async _getDataType(class_name): Promise<protobuf.Type | undefined> {
    const DataType = this.map[class_name]['proto_class_data_type'];

    if (!DataType) return;
    return this.root.lookupType(DataType);
  }
}