"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const protobufjs = require("protobufjs/light");
const axios_1 = require("axios");
const FormData = require("form-data");
const buffer_1 = require("buffer");
class RpcServices {
    constructor(___client) {
        this.___client = ___client;
        this.___class_ctors = {};
    }
    _createInstance(class_name, state) {
        return __awaiter(this, void 0, void 0, function* () {
            const _services = this;
            const ClassName = _services.___class_ctors[class_name];
            const instance = new ClassName(state);
            instance.__rpc_client = this.___client;
            instance.__updateData && instance.__updateData(state);
            return instance;
        });
    }
}
class RpcClient {
    constructor(url, headers, Services) {
        this.url = url;
        this.headers = headers;
        this.Services = Services;
    }
    get map() {
        if (!this._map)
            throw Error('Please initiate the app first');
        return this._map;
    }
    ;
    get root() {
        if (!this._root)
            throw Error('Please initiate the app first');
        return this._root;
    }
    ;
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this._map = yield require('./def.map.json');
            this._root = yield protobufjs.Root.fromJSON(require('./def.proto.json'));
            if (!this.services)
                this.services = new this.Services(this);
            return undefined;
        });
    }
    callMethod(instance, class_name, method_name, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoded = yield this._encodeRequest(instance, class_name, method_name, args);
            const response = yield this._callMethod(instance, class_name, method_name, encoded.data, encoded.args);
            return this._decodeResponse(instance, class_name, method_name, response);
        });
    }
    _decodeResponse(instance, class_name, method_name, _response) {
        return __awaiter(this, void 0, void 0, function* () {
            const ReturnType = yield this._getReturnType(class_name, method_name);
            const { isReturnTypeClass, return_type } = yield this._getMethodMetadata(class_name, method_name);
            const message = ReturnType.decode(_response);
            const { data, response } = ReturnType.toObject(message, {
                enums: String,
                longs: Number,
                bytes: String,
                defaults: true,
                arrays: true,
                objects: true,
                oneofs: true // includes virtual oneof fields set to the present field's name
            });
            instance.__updateData && instance.__updateData(data);
            if (isReturnTypeClass()) {
                return Array.isArray(response)
                    ? Promise.all(response.map((state) => this.services._createInstance(return_type.ctor, state)))
                    : yield this.services._createInstance(return_type.ctor, response);
            }
            return response;
        });
    }
    _callMethod(instance, class_name, method_name, data, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const form = new FormData();
            form.append('args', args, { filename: 'args' });
            data && form.append('data', data, { filename: 'data' });
            form.append('method', method_name);
            form.append('class', class_name);
            try {
                const request = yield axios_1.default.post(this.url, form, {
                    responseType: "arraybuffer",
                    headers: { 'content-type': `multipart/form-data; boundary=${form.getBoundary()}` }
                });
                return buffer_1.Buffer.from(request.data, "binary");
            }
            catch (e) {
                throw e.response && e.response.data && e.response.data || e;
            }
        });
    }
    _encodeRequest(instance, class_name, method_name, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const RequestType = yield this._getRequestType(class_name, method_name);
            const ClassDataType = yield this._getDataType(class_name);
            // Encode a message to an Uint8Array (browser) or Buffer (node)
            const method_args = {};
            const method_arguments = yield this._getArgumentTypes(class_name, method_name);
            (method_arguments || []).forEach(({ index, identifier }) => {
                method_args[identifier] = args[index];
            });
            const encoded = {
                args: yield this._encodeWithType(RequestType, method_args),
                data: undefined
            };
            if (ClassDataType) {
                encoded['data'] = yield this._encodeWithType(ClassDataType, instance.getData());
            }
            return encoded;
        });
    }
    _encodeWithType(type, data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data)
                return;
            // 1. Verify data
            const errMsg = type.verify(data);
            if (errMsg)
                throw Error(errMsg);
            // 2. encode protobuf
            // Create a new message// or use .fromObject if conversion is necessary
            const message = type.create(data);
            // Encode a message to an Uint8Array (browser) or Buffer (node)
            return type.encode(message).finish();
        });
    }
    _getArgumentTypes(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { request_type } = yield this._getMethodMetadata(class_name, method_name);
            return request_type.args;
        });
    }
    _getRequestType(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { request_type } = yield this._getMethodMetadata(class_name, method_name);
            const type = this.root.lookupType(request_type.proto);
            if (!type)
                throw Error('Method not found');
            return type;
        });
    }
    _getReturnType(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const { return_type } = yield this._getMethodMetadata(class_name, method_name);
            const type = this.root.lookupType(return_type.proto);
            if (!type)
                throw Error('Return type not found');
            return type;
        });
    }
    _getMethodMetadata(class_name, method_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = this.map[class_name]['methods'][method_name];
            const return_type = metadata['return_type'];
            const request_type = metadata['request_type'];
            return {
                metadata,
                request_type,
                return_type,
                return_proto_type: return_type.proto,
                return_constructor_type: return_type.ctor,
                isReturnTypeClass: () => {
                    return return_type.datatype === 'class';
                }
            };
        });
    }
    _getDataType(class_name) {
        return __awaiter(this, void 0, void 0, function* () {
            const DataType = this.map[class_name]['proto_class_data_type'];
            if (!DataType)
                return;
            return this.root.lookupType(DataType);
        });
    }
}
