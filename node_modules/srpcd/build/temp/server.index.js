"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const protobufjs = require("protobufjs");
function decodeMessage(msg) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const root = yield protobufjs.load('class.metadata.proto');
        const ClassState = root.lookupType('ClassState');
        const CallMetadata = root.lookupType('CallMetadata');
        const service = (root.lookup('SimpleRpc'));
        const impl = service.create(function (method, requestData, callback) {
            // console.log(err, res)
            callback(null, CallMetadata.encodeDelimited({ test: 'res' }).finish());
        }, true, true);
        const method = service.methods['getClassState'];
        if (!(((_a = method.resolvedRequestType) === null || _a === void 0 ? void 0 : _a.ctor) && ((_b = method.resolvedResponseType) === null || _b === void 0 ? void 0 : _b.ctor)))
            return;
        impl.rpcCall(method, method.resolvedRequestType.ctor, method.resolvedResponseType.ctor, ClassState.decodeDelimited(ClassState.encodeDelimited({ test: 'req' }).finish()), function (err, res) {
            console.log(err, res);
        });
    });
}
decodeMessage();
//
// var root = protobuf.Root.fromJSON({
//   nested: {
//     Greeter: {
//       methods: {
//         "SayHello": {
//           requestType: "Hello",
//           requestStream: true,
//           responseType: "World",
//           responseStream: true
//         }
//       }
//     },
//     Hello: {
//       fields: {
//         name: {
//           type: "string",
//           id: 1
//         }
//       }
//     },
//     World: {
//       fields: {
//         message_parts: {
//           type: "string",
//           id: 1
//         }
//       }
//     }
//   }
// });
//
// // Get its types:
//
// var Greeter: Service = root.lookup("Greeter")! as any,
//   Hello   = root.lookupType("Hello")!,
//   World   = root.lookupType("World")!;
//
// // Provide a stream-aware RPC implementation:
//
// var greeter: any = Greeter.create(/* rpcImpl */ (function() { // API documentation: Service#create
//   var ended = false;
//   return function myRPCImpl(method: any, requestData: any, callback: any) {
//     if (ended)
//       return;
//     if (!requestData) {
//       ended = true;
//       return;
//     }
//     // in a real-world scenario, the client would now send requestData to a server using some
//     // sort of transport layer (i.e. http), wait for responseData and call the callback.
//     performRequestOverTransportChannel(requestData, function(responseData: any) {
//       callback(null, responseData);
//     });
//   };
// })(), /* requestDelimited? */ true, /* responseDelimited? */ true);
//
// // examplary server-side code for the sake of this example
// function performRequestOverTransportChannel(requestData: any, callback: any) {
//   setTimeout(/* simulated delay */function() {
//     // 1. server decodes the request
//     var request: any = Hello.decodeDelimited(requestData);
//     // 2. server handles the request and creates a response
//     var response = { message_parts: "Hello " + request.name };
//     setTimeout(/* simulated delay */function() {
//       // 3. server encodes and sends the response
//       callback(World.encodeDelimited(response).finish());
//     }, Math.random() * 250);
//   }, Math.random() * 250);
// }
//
// // Listen for events:
//
// greeter.on("data", function(response: any, method: any) {
//   console.log("data in " + method.name + ":", response.message);
// });
//
// greeter.on("end", function() {
//   console.log("end");
// });
//
// greeter.on("error", function(err: any, method: any) {
//   console.log("error in " + method.name + ":", err);
// });
//
// // Call methods:
//
// greeter.sayHello({ name: "one" });
// greeter.sayHello(Hello.create({ name: "two" })); // or use runtime messages
//
// // Listen to and emit your own events if you like:
//
// greeter.on("status", function(code: any, text: any) {
//   console.log("custom status:", code, text);
// });
//
// greeter.emit("status", 200, "OK");
//
// // And, if applicable, end the service when you are done:
//
// setTimeout(function() {
//   // greeter.end();
//   // ^ Signals rpcImpl that the service has been ended client-side by calling it with a null buffer.
//   //   Likewise, rpcImpl can also end the stream by calling its callback with an explicit null buffer.
//   greeter.sayHello({ name: "three" }, function(err: any) {
//     console.error("this should fail: " + err?.message);
//   });
// }, 2000);
