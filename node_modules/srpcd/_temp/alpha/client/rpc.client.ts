import * as protobufjs from 'protobufjs/light'
import axios from "axios";
import { Buffer } from "buffer";

class RpcServices {
  protected ___class_ctors = {};
  constructor(protected ___client: RpcClient) {}
  public async _createInstance(class_name, state: any) {
    const _services: any = this
    const ClassName = _services.___class_ctors[class_name];

    const instance = new ClassName(state);
    instance.__rpc_client = this.___client;
    instance.__updateData && instance.__updateData(state);
    return instance;
  }
}

class RpcClient<Service = undefined, ServicesType extends RpcServices = RpcServices> {
  protected services!: ServicesType;
  private _map?: MetadataSchema;
  private _root?: protobufjs.Root;
  private get map() {
    if (!this._map) throw Error('Please initiate the app first')
    return this._map;
  };
  private get root() {
    if (!this._root) throw Error('Please initiate the app first')
    return this._root;
  };

  constructor(protected url: string, protected headers: any, protected Services: any) {}

  async init(): Promise<Service> {
    this._map = await require('./def.map.json');
    this._root = await protobufjs.Root.fromJSON(require('./def.proto.json'));

    if (!this.services) this.services = new this.Services(this);
    return undefined as any
  }

  async callMethod(instance: any, class_name: any, method_name: any, args: any) {
    const encoded = await this._encodeRequest(instance, class_name, method_name, args)
    const response = await this._callMethod(instance, class_name, method_name, encoded.data, encoded.args)
    return this._decodeResponse(instance, class_name, method_name, response)
  }

  private async _decodeResponse(instance, class_name, method_name, _response) {
    const ReturnType = await this._getReturnType(class_name, method_name);
    const { isReturnTypeClass, return_type } = await this._getMethodMetadata(class_name, method_name);

    const { data, response } = (this.decode(ReturnType, _response) || {})as any;
    console.log(data, response)
    instance.__updateData && instance.__updateData(data);
    if (isReturnTypeClass()) {
      return Array.isArray(response)
        ? Promise.all(response.map((state) => this.services._createInstance(return_type.ctor, state)))
        : this.services._createInstance(return_type.ctor, response);
    }

    return response as any;
  }

  private decode(type, data) {
    if (!data) return;

    return type.toObject(type.decode(data), {
      enums: String,  // enums as string names
      longs: Number,  // longs as strings (requires long.js)
      bytes: String,  // bytes as base64 encoded strings
      defaults: true, // includes default values
      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
      objects: true,  // populates empty objects (map fields) even if defaults=false
      oneofs: true    // includes virtual oneof fields set to the present field's name
    }) as any;
  }

  private async _callMethod(instance: any, class_name, method_name, data, args) {
    const form = new FormData();
    form.append('args', new Blob([args], { type: 'arraybuffer' }), 'args' );
    form.append('data', new Blob([data], { type: 'arraybuffer' }), 'data' );
    form.append('method', method_name);
    form.append('class', class_name);

    const request = await axios.post(this.url, form, {
      responseType: "arraybuffer",
    });

    return Buffer.from(request.data);
  }

  private async _encodeRequest(instance, class_name, method_name, args: any[]) {
    const RequestType = await this._getRequestType(class_name, method_name);
    const ClassDataType = await this._getDataType(class_name);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    const method_args: any = { };
    const method_arguments = await this._getArgumentTypes(class_name, method_name);
    (method_arguments || []).forEach(({ index, identifier }) => {
      method_args[identifier] = args[index];
    })

    const encoded = {
      args: await this._encodeWithType(RequestType, method_args),
      data: undefined
    };

    const class_state = instance.getData && instance.getData()
    if (ClassDataType && class_state) {
      encoded['data'] = await this._encodeWithType(ClassDataType, class_state)
    }

    return encoded;
  }

  private async _encodeWithType(type, data) {
    if (!data) return;

    // 1. Verify data
    const errMsg = type.verify(data);
    if (errMsg) throw Error(errMsg);

    // 2. encode protobuf
    // Create a new message// or use .fromObject if conversion is necessary
    const message = type.create(data);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    return  type.encode(message).finish();
  }

  private async _getArgumentTypes(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    return request_type.args;
  }

  private async _getRequestType(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(request_type.proto);
    if (!type) throw Error('Method not found')
    return type
  }

  private async _getReturnType(class_name, method_name): Promise<protobuf.Type> {
    const { return_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(return_type.proto);
    if (!type) throw Error('Return type not found')
    return type
  }

  private async _getMethodMetadata(class_name, method_name) {
    const metadata = this.map[class_name]['methods'][method_name];
    const return_type = metadata['return_type'];
    const request_type = metadata['request_type'];

    return {
      metadata,
      request_type,
      return_type,
      return_proto_type: return_type.proto,
      return_constructor_type: return_type.ctor,
      isReturnTypeClass: () => {
        return return_type.datatype === 'class'
      }
    }
  }

  private async _getDataType(class_name): Promise<protobuf.Type | undefined> {
    const DataType = this.map[class_name]['proto_class_data_type'];
    if (!DataType) return;
    return this.root.lookupType(DataType);
  }
}

interface MetadataSchemaClassType {
  [method: string]: {
    request_type: {
      proto: string,
      constructor: string
      args: { index: number, identifier: string }[],
    },
    return_type: {
      proto: string,
      ctor: string
      datatype: string
    },
  }
}

interface MetadataSchema {
  [data_or_class_name: string]: {
    methods: MetadataSchemaClassType
  }
}
export class Services extends RpcServices {
  constructor(protected ___client: RpcClient) {
    super(___client);
    for (let service in this) {
      if (typeof this[service] === "object" && service !== '___client')
        (this[service] as any).__rpc_client = this.___client;
    }
  }

	conversation:Conversation = new Conversation();
	conversation1:Conversation1 = new Conversation1();
	message:Message = new Message();
	chat:Chat = new Chat();
	___class_ctors = {
		Conversation: Conversation,
		Conversation1: Conversation1,
		Message: Message,
		Chat: Chat,
	}
}

export interface CreateConversationArg {
	userId: string[]
	name: string
	name_song: string
	nameSong: string 
}
export class Conversation {
  private __rpc_client!: RpcClient;
  private async callMethod(name: string, data: any): Promise<any> {
    return this.__rpc_client.callMethod(this, 'Conversation', name, data)
  }
  private $___class_state!: EmptyClassData;
  getData(): EmptyClassData { return this.$___class_state || {} }
  __updateData(data: Partial<EmptyClassData>){ this.$___class_state = Object.assign(this.$___class_state || {}, data || {}) }
  public getMessages(): Promise<CreateConversationArg> {
    return this.callMethod('getMessages', arguments);
  }
  public getMessageCount(): Promise<number> {
    return this.callMethod('getMessageCount', arguments);
  }
  public sendMessage(): Promise<CreateConversationArg[]> {
    return this.callMethod('sendMessage', arguments);
  }
}
export class Conversation1 {
  private __rpc_client!: RpcClient;
  private async callMethod(name: string, data: any): Promise<any> {
    return this.__rpc_client.callMethod(this, 'Conversation1', name, data)
  }
  private $___class_state!: EmptyClassData;
  getData(): EmptyClassData { return this.$___class_state || {} }
  __updateData(data: Partial<EmptyClassData>){ this.$___class_state = Object.assign(this.$___class_state || {}, data || {}) }
  public getMessages(): Promise<CreateConversationArg[]> {
    return this.callMethod('getMessages', arguments);
  }
  public getMessageCount(): Promise<string[]> {
    return this.callMethod('getMessageCount', arguments);
  }
  public sendMessage(): Promise<CreateConversationArg> {
    return this.callMethod('sendMessage', arguments);
  }
}
export class Message {
  private __rpc_client!: RpcClient;
  private async callMethod(name: string, data: any): Promise<any> {
    return this.__rpc_client.callMethod(this, 'Message', name, data)
  }
  private $___class_state!: EmptyClassData;
  getData(): EmptyClassData { return this.$___class_state || {} }
  __updateData(data: Partial<EmptyClassData>){ this.$___class_state = Object.assign(this.$___class_state || {}, data || {}) }
  public getMessages(k: string[], name: CreateConversationArg): Promise<CreateConversationArg> {
    return this.callMethod('getMessages', arguments);
  }
  public getMessageCount(): Promise<number> {
    return this.callMethod('getMessageCount', arguments);
  }
  public sendMessage(): Promise<CreateConversationArg> {
    return this.callMethod('sendMessage', arguments);
  }
}
export class Chat {
  private __rpc_client!: RpcClient;
  private async callMethod(name: string, data: any): Promise<any> {
    return this.__rpc_client.callMethod(this, 'Chat', name, data)
  }
  private $___class_state!: EmptyClassData;
  getData(): EmptyClassData { return this.$___class_state || {} }
  __updateData(data: Partial<EmptyClassData>){ this.$___class_state = Object.assign(this.$___class_state || {}, data || {}) }
  public deleteConversation(id: string): Promise<string> {
    return this.callMethod('deleteConversation', arguments);
  }
  public setName(name: string): Promise<string[]> {
    return this.callMethod('setName', arguments);
  }
  public getConversationById(id: string): Promise<CreateConversationArg[]> {
    return this.callMethod('getConversationById', arguments);
  }
  public getConversations(): Promise<CreateConversationArg> {
    return this.callMethod('getConversations', arguments);
  }
  public getConversationCount(): Promise<CreateConversationArg> {
    return this.callMethod('getConversationCount', arguments);
  }
  public createConversation(userId: string): Promise<CreateConversationArg> {
    return this.callMethod('createConversation', arguments);
  }
}