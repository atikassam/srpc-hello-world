import * as protobufjs from 'protobufjs'
import * as http from "http";
import * as Busboy from "busboy";
import {IncomingMessage, ServerResponse} from "http";
// import * as express from "express";

export interface SrpcServerOptions {
  enable_cors: boolean
}

class SrpcServer<SrpcClasses> {
  private options?: SrpcServerOptions;
  private _map?: any;
  private _root?: protobufjs.Root;

  private get map() {
    if (!this._map) throw Error('Please initiate the app first')
    return this._map;
  };

  private get root() {
    if (!this._root) throw Error('Please initiate the app first')
    return this._root;
  };

  constructor(private implementations: SrpcClasses) {
    this.init()
  }

  private async init() {
    this._map = await require('./def.map.json');
    this._root = await protobufjs.Root.fromJSON(require('./def.proto.json'));

    return this;
  }

  createServer(options?: { enable_cors: boolean }) {
    return http.createServer((req, res) => {
      if (options?.enable_cors) this.enableCors(req, res);
      this.requestHandler(req, res);
    })
  }

  public useExpressHandler = (req: IncomingMessage, res: ServerResponse) => {
    return this.requestHandler(req, res);
  }

  public useKoaHandler = (ctx: { req: IncomingMessage, res: ServerResponse }) => {
    return this.requestHandler(ctx.req, ctx.res);
  }

  private requestHandler(req: IncomingMessage, res: ServerResponse) {
    const meta: any = {}, busboy = new Busboy({headers: req.headers});

    busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {
      const buf: any[] = [];
      file.on('data',  (data) => buf.push(data));
      file.on('end', () => meta[fieldname] = Buffer.concat(buf));
    });

    busboy.on('field', function (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) {
      meta[fieldname] = val;
    });
    busboy.on('finish', async  () => {
      const response = await this.callMethod(meta['class'], meta['method'], meta['data'], meta['args']);
      res.write(response);
      res.end();
    });
    req.pipe(busboy);
  }

  private enableCors(req: IncomingMessage, res: ServerResponse) {
    // Website you wish to allow to connect
    res.setHeader('Access-Control-Allow-Origin', '*');

    // Request methods you wish to allow
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');

    // Request headers you wish to allow
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type');

    // Set to true if you need the website to include cookies in the requests sent
    // to the API (e.g. in case you use sessions)
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }

  protected async callMethod(class_name: any, method_name: any, data: any, args) {
    const decoded = await this._decodeRequest(class_name, method_name, data, args)
    const _return = await this._callMethod(class_name, method_name, decoded)
    return this._encodeResponse(class_name, method_name, _return)
  }

  private async _decodeRequest(class_name, method_name, data, args) {
    const ClassDataType = await this._getDataType(class_name);
    const RequestType = await this._getRequestType(class_name, method_name);
    const decoded_args: any = this.decode(RequestType, args);
    const decoded_data: any = ClassDataType && data ? this.decode(ClassDataType, data) : undefined;

    return { args: decoded_args, data: decoded_data };
  }

  private decode(type, data) {
    return type.toObject(type.decode(data), {
      enums: String,  // enums as string names
      longs: Number,  // longs as strings (requires long.js)
      bytes: String,  // bytes as base64 encoded strings
      defaults: true, // includes default values
      arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
      objects: true,  // populates empty objects (map fields) even if defaults=false
      oneofs: true    // includes virtual oneof fields set to the present field's name
    }) as any;
  }

  private async _callMethod(class_name, method_name, { args, data }) {
    const { isReturnTypeClass } = await this._getMethodMetadata(class_name, method_name);

    const _args: any[] = [];
    const method_arguments = await this._getArgumentTypes(class_name, method_name);
    method_arguments.forEach(({ identifier, index }) => _args[index] = args[identifier]);

    const ClassCtor = (this.implementations as any)[class_name];
    const instance = new ClassCtor(data);
    const _return =  await instance[method_name](..._args);

    console.log(_return)

    return {
      class_data: instance.getData && instance.getData(),
      response: isReturnTypeClass()
        ? Array.isArray(_return)
          ? _return.map((instance) => instance.getData ? instance.getData() : {})
          : instance.getData ? instance.getData() : {}
        : _return
    };
  }

  private async _encodeResponse(class_name, method_name, { response, class_data }) {
    const ReturnType = await this._getReturnType(class_name, method_name);

    const _return: { data?, response? } = {};
    if (response) _return["response"] = response;
    if (class_data) _return["data"] = class_data;

    // 1. Verify data
    const errMsg = ReturnType.verify(_return);
    if (errMsg) throw Error(errMsg);

    // 2. encode protobuf
    // Create a new message
    // or use .fromObject if conversion is necessary
    const message = ReturnType.create(_return);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    return ReturnType.encode(message).finish();
  }

  private async _getArgumentTypes(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    return request_type.args;
  }

  private async _getRequestType(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(request_type.proto);
    if (!type) throw Error('Method not found')
    return type
  }

  private async _getReturnType(class_name, method_name): Promise<protobuf.Type> {
    const { return_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(return_type.proto);
    if (!type) throw Error('Return type not found')
    return type
  }

  private async _getMethodMetadata(class_name, method_name) {
    const metadata = this.map[class_name]['methods'][method_name];
    const return_type = metadata['return_type'];
    const request_type = metadata['request_type'];

    return {
      metadata,
      request_type,
      return_type,
      return_proto_type: return_type.proto,
      return_constructor_type: return_type.ctor,
      isReturnTypeClass: () => {
        return return_type.datatype === 'class'
      }
    }
  }

  private async _getDataType(class_name): Promise<protobuf.Type | undefined> {
    const DataType = this.map[class_name]['proto_class_data_type'];
    if (!DataType) return;
    return this.root.lookupType(DataType);
  }
}
export interface CreateConversationArg {
	userId: string[]
	name: string
	name_song: string
	nameSong: string 
}
export abstract class Conversation {
	private $___class_state!: EmptyClassData;
	constructor(data: EmptyClassData) { this.$___class_state = data; }
	getData(){ return this.$___class_state }
	updateData(data: Partial<EmptyClassData>){ Object.assign(this.$___class_state, data) }
	public abstract getMessages(): Promise<CreateConversationArg>
	public abstract getMessageCount(): Promise<number>
	public abstract sendMessage(): Promise<CreateConversationArg[]>
}
export abstract class Conversation1 {
	private $___class_state!: EmptyClassData;
	constructor(data: EmptyClassData) { this.$___class_state = data; }
	getData(){ return this.$___class_state }
	updateData(data: Partial<EmptyClassData>){ Object.assign(this.$___class_state, data) }
	public abstract getMessages(): Promise<CreateConversationArg[]>
	public abstract getMessageCount(): Promise<string[]>
	public abstract sendMessage(): Promise<CreateConversationArg>
}
export abstract class Message {
	private $___class_state!: EmptyClassData;
	constructor(data: EmptyClassData) { this.$___class_state = data; }
	getData(){ return this.$___class_state }
	updateData(data: Partial<EmptyClassData>){ Object.assign(this.$___class_state, data) }
	public abstract getMessages(k: string[], name: CreateConversationArg): Promise<CreateConversationArg>
	public abstract getMessageCount(): Promise<number>
	public abstract sendMessage(): Promise<CreateConversationArg>
}
export abstract class Chat {
	private $___class_state!: EmptyClassData;
	constructor(data: EmptyClassData) { this.$___class_state = data; }
	getData(){ return this.$___class_state }
	updateData(data: Partial<EmptyClassData>){ Object.assign(this.$___class_state, data) }
	public abstract deleteConversation(id: string): Promise<string>
	public abstract setName(name: string): Promise<string[]>
	public abstract getConversationById(id: string): Promise<CreateConversationArg[]>
	public abstract getConversations(): Promise<CreateConversationArg>
	public abstract getConversationCount(): Promise<CreateConversationArg>
	public abstract createConversation(userId: string): Promise<CreateConversationArg>
}
interface SrpcClasses {
	Conversation?: typeof Conversation;
	Conversation1?: typeof Conversation1;
	Message?: typeof Message;
	Chat?: typeof Chat;
}
