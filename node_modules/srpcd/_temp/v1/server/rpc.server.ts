import * as protobufjs from 'protobufjs'
import * as http from "http";
import * as Busboy from "busboy";
import {IncomingMessage, ServerResponse} from "http";
// import * as express from "express";

export interface SrpcServerOptions {
  enable_cors: boolean
}

class SrpcServer<SrpcClasses> {
  private options?: SrpcServerOptions;
  private _map?: any;
  private _root?: protobufjs.Root;

  private get map() {
    if (!this._map) throw Error('Please initiate the app first')
    return this._map;
  };

  private get root() {
    if (!this._root) throw Error('Please initiate the app first')
    return this._root;
  };

  private server: any;

  constructor(private implementations: SrpcClasses) {}

  public async init(options: SrpcServerOptions) {
    this.options = options;
    this._map = await require('./def.map.json');
    this._root = await protobufjs.Root.fromJSON(require('./def.proto.json'));
  }

  public listen(port: number) {
    return http.createServer((req, res) => {
      if (this.options?.enable_cors) this.enableCors(req, res);
      this.requestHandler(req, res);
    }).listen(port);
  }

  public withExpress(req: IncomingMessage, res: ServerResponse) {
    return this.requestHandler(req, res);
  }

  private requestHandler(req: IncomingMessage, res: ServerResponse) {
    const meta: any = {}, busboy = new Busboy({headers: req.headers});

    busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {
      const buf: any[] = [];
      file.on('data',  (data) => buf.push(data));
      file.on('end', () => meta[fieldname] = Buffer.concat(buf));
    });

    busboy.on('field', function (fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) {
      meta[fieldname] = val;
    });
    busboy.on('finish', async  () => {
      const response = await this.callMethod(meta['class'], meta['method'], meta['data'], meta['args']);
      res.write(response);
      res.end();
    });
    req.pipe(busboy);
  }

  private enableCors(req: IncomingMessage, res: ServerResponse) {
    // Website you wish to allow to connect
    res.setHeader('Access-Control-Allow-Origin', '*');

    // Request methods you wish to allow
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');

    // Request headers you wish to allow
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type');

    // Set to true if you need the website to include cookies in the requests sent
    // to the API (e.g. in case you use sessions)
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }

  protected async callMethod(class_name: any, method_name: any, data: any, args) {
    const decoded = await this._decodeRequest(class_name, method_name, data, args)
    const { response } = await this._callMethod(class_name, method_name, decoded)
    return this._encodeResponse(class_name, method_name, response)
  }

  private async _decodeRequest(class_name, method_name, data, args) {
    const ClassDataType = await this._getDataType(class_name);
    const RequestType = await this._getRequestType(class_name, method_name);
    const decoded_args: any = RequestType.decode(args);
    const decoded_data: any = ClassDataType.decode(data);

    return { args: decoded_args, data: decoded_data };
  }

  private async _callMethod(class_name, method_name, { args, data }) {
    const _args: any[] = [];
    const method_arguments = this.map[class_name][method_name]['arguments'];

    Object.keys(method_arguments || {})
      .forEach(arg => _args[parseInt(method_arguments[arg])] = args[arg]);

    const ClassCtor = (this.implementations as any)[class_name];
    const instance = new ClassCtor(data);
    return {
      response: await instance[method_name](..._args)
    };
  }

  private async _encodeResponse(class_name, method_name, _response) {
    const ReturnType = await this._getReturnType(class_name, method_name);
    const { isReturnTypeClass } = await this._getMethodMetadata(class_name, method_name);

    const response = isReturnTypeClass() ? _response.getData() : _response;

    // 1. Verify data
    const errMsg = ReturnType.verify({ response });
    if (errMsg) throw Error(errMsg);

    // 2. encode protobuf
    // Create a new message
    // or use .fromObject if conversion is necessary
    const message = ReturnType.create({ response });

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    return ReturnType.encode(message).finish();
  }

  private async _getArgumentTypes(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    return request_type.args;
  }

  private async _getRequestType(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(request_type.proto);
    if (!type) throw Error('Method not found')
    return type
  }

  private async _getReturnType(class_name, method_name): Promise<protobuf.Type> {
    const { return_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(return_type.proto);
    if (!type) throw Error('Return type not found')
    return type
  }

  private async _getMethodMetadata(class_name, method_name) {
    const metadata = this.map[class_name]['methods'][method_name];
    const return_type = metadata['return_type'];
    const request_type = metadata['request_type'];

    return {
      metadata,
      request_type,
      return_type,
      return_proto_type: return_type.proto,
      return_constructor_type: return_type.ctor,
      isReturnTypeClass: () => {
        return return_type.datatype === 'class'
      }
    }
  }

  private async _getDataType(class_name): Promise<protobuf.Type> {
    const type = this.root.lookupType(this.map[class_name]['proto_class_data_type']);
    if (!type) throw Error('Class data type not found')
    return type
  }
}
export interface FileMetadata {
	 
}
export abstract class File {
	private $___class_state!: FileMetadata;
	constructor(data: FileMetadata) { this.$___class_state = data; }
	getData(){ return this.$___class_state }
	updateData(data: Partial<FileMetadata>){ Object.assign(this.$___class_state, data) }
}
export abstract class File2 {
}
export abstract class FileList {
	private $___class_state!: FileMetadata;
	constructor(data: FileMetadata) { this.$___class_state = data; }
	getData(){ return this.$___class_state }
	updateData(data: Partial<FileMetadata>){ Object.assign(this.$___class_state, data) }
	public abstract getFile(id: string): Promise<File>
	public abstract getFiles(): Promise<FileMetadata[]>
}
interface SrpcClasses {
	File?: typeof File;
	File2?: typeof File2;
	FileList?: typeof FileList;
}

export class SimpleRpcServer extends SrpcServer<SrpcClasses> {
  constructor(classes: SrpcClasses) {
    super(classes)
  }
}
