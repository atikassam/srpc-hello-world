import * as protobufjs from 'protobufjs/light'
import axios from "axios";

class RpcServices {
  constructor(protected ___client: RpcClient) {}
  public async _createClass(class_name, state: any) {
    const _services: any = this
    const ClassName = _services.classes[class_name];

    const instance = new ClassName(state);
    instance.__rpc_client = this.___client;
    instance.__updateData(state);
    return instance;
  }
}

class RpcClient<ServicesType extends RpcServices = RpcServices> {
  private services!: ServicesType;
  private _map?: MetadataSchema;
  private _root?: protobufjs.Root;
  private get map() {
    if (!this._map) throw Error('Please initiate the app first')
    return this._map;
  };
  private get root() {
    if (!this._root) throw Error('Please initiate the app first')
    return this._root;
  };

  constructor(protected url: string, protected headers: any, protected Services: any) {}

  async init() {
    this._map = await require('./def.map.json');
    this._root = await protobufjs.Root.fromJSON(require('./def.proto.json'));

    if (!this.services) this.services = new this.Services(this);
    return this.services
  }

  async callMethod(instance: any, class_name: any, method_name: any, args: any) {
    const encoded = await this._encodeRequest(instance, class_name, method_name, args)
    const response = await this._callMethod(instance, class_name, method_name, encoded.data, encoded.args)
    return this._decodeResponse(instance, class_name, method_name, response)
  }

  private async _decodeResponse(instance, class_name, method_name, _response) {
    const ReturnType = await this._getReturnType(class_name, method_name);
    const { isReturnTypeClass, return_type } = await this._getMethodMetadata(class_name, method_name);

    const { data, response } = ReturnType.decode(_response) as any;
    instance.__updateData(data);

    if (isReturnTypeClass()) {
      return Array.isArray(response)
        ? response.map((state) => this.services._createClass(return_type.ctor, state))
        : this.services._createClass(return_type.ctor, response);
    }

    return response as any;
  }

  private async _createClass(class_name, state: any) {
    return this.services._createClass(class_name, state);
  }

  private async _callMethod(instance: any, class_name, method_name, data, args) {
    const form = new FormData();
    form.append('args', new Blob([args], { type: 'arraybuffer' }), 'args' );
    form.append('data', new Blob([data], { type: 'arraybuffer' }), 'data' );
    form.append('method', method_name);
    form.append('class', class_name);

    const request = await axios.post(this.url, form, {
      responseType: "arraybuffer",
    });

    return request.data;
  }

  private async _encodeRequest(instance, class_name, method_name, args: any[]) {
    const RequestType = await this._getRequestType(class_name, method_name);
    const ClassDataType = await this._getDataType(class_name);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    const method_args: any = { };
    const method_arguments = await this._getArgumentTypes(class_name, method_name);
    (method_arguments || []).forEach(({ index, identifier }) => {
      method_args[identifier] = args[index];
    })

    const encoded = {
      args: await this._encodeWithType(RequestType, method_args),
      data: undefined
    };

    if (ClassDataType) {
      encoded['data'] = await this._encodeWithType(ClassDataType, instance.getData())
    }

    return encoded;
  }

  private async _encodeWithType(type, data) {
    // 1. Verify data
    const errMsg = type.verify(data);
    if (errMsg) throw Error(errMsg);

    // 2. encode protobuf
    // Create a new message// or use .fromObject if conversion is necessary
    const message = type.create(data);

    // Encode a message to an Uint8Array (browser) or Buffer (node)
    return  type.encode(message).finish();
  }

  private async _getArgumentTypes(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    return request_type.args;
  }

  private async _getRequestType(class_name, method_name) {
    const { request_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(request_type.proto);
    if (!type) throw Error('Method not found')
    return type
  }

  private async _getReturnType(class_name, method_name): Promise<protobuf.Type> {
    const { return_type } = await this._getMethodMetadata(class_name, method_name);
    const type = this.root.lookupType(return_type.proto);
    if (!type) throw Error('Return type not found')
    return type
  }

  private async _getMethodMetadata(class_name, method_name) {
    const metadata = this.map[class_name]['methods'][method_name];
    const return_type = metadata['return_type'];
    const request_type = metadata['request_type'];

    return {
      metadata,
      request_type,
      return_type,
      return_proto_type: return_type.proto,
      return_constructor_type: return_type.ctor,
      isReturnTypeClass: () => {
        return return_type.datatype === 'class'
      }
    }
  }

  private async _getDataType(class_name): Promise<protobuf.Type> {
    return this.root.lookupType(this.map[class_name]['proto_class_data_type']);
  }
}

interface MetadataSchemaClassType {
  [method: string]: {
    request_type: {
      proto: string,
      constructor: string
      args: { index: number, identifier: string }[],
    },
    return_type: {
      proto: string,
      ctor: string
      datatype: string
    },
  }
}

interface MetadataSchema {
  [data_or_class_name: string]: {
    methods: MetadataSchemaClassType
  }
}
export class SimpleRpcClient extends RpcClient<Services> {
  constructor(protected url: string, protected headers: any) {
    super(url, headers, Services)
  }
}

export class Services extends RpcServices {
  constructor(protected ___client: RpcClient) {
    super(___client);
    for (let service in this) {
      if (typeof this[service] === "object" && service !== '___client')
        (this[service] as any).__rpc_client = this.___client;
    }
  }

	file:File = new File();
	file2:File2 = new File2();
	filelist:FileList = new FileList();
}

export interface FileMetadata {
	 
}
export class File {
  private __rpc_client!: RpcClient;
  private async callMethod(name: string, data: any): Promise<any> {
    return this.__rpc_client.callMethod(this, 'File', name, data)
  }
  private $___class_state!: FileMetadata;
  getData(): FileMetadata { return this.$___class_state }
  __updateData(data: Partial<FileMetadata>){ Object.assign(this.$___class_state, data) }
}
export class File2 {
  private __rpc_client!: RpcClient;
  private async callMethod(name: string, data: any): Promise<any> {
    return this.__rpc_client.callMethod(this, 'File2', name, data)
  }
}
export class FileList {
  private __rpc_client!: RpcClient;
  private async callMethod(name: string, data: any): Promise<any> {
    return this.__rpc_client.callMethod(this, 'FileList', name, data)
  }
  private $___class_state!: FileMetadata;
  getData(): FileMetadata { return this.$___class_state }
  __updateData(data: Partial<FileMetadata>){ Object.assign(this.$___class_state, data) }
  public getFile(id: string): Promise<File> {
    return this.callMethod('getFile', arguments);
  }
  public getFiles(): Promise<FileMetadata[]> {
    return this.callMethod('getFiles', arguments);
  }
}